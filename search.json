[{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://keaven.github.io/gsDesignNB/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://keaven.github.io/gsDesignNB/articles/completers-interim-example.html","id":"simulation-setup","dir":"Articles","previous_headings":"","what":"Simulation setup","title":"Group sequential simulation with completers analysis","text":"define trial following parameters: Sample Size: 200 patients. Enrollment: Recruited 12 months. Follow-: 2 years maximum follow-per patient. Interim Analysis: Conducted 40% patients (80 subjects) completed 2-year follow-. interim analysis includes data available time (completers partial follow-). Final Analysis: Conducted patients completed follow-(dropped ). Includes available data.","code":"# Parameters n_total <- 200 enroll_duration <- 12 # months max_followup <- 12 # months (using months as time unit for clarity)  # Convert to years if rates are annual, but let's stick to consistent units. # Let's say rates are per YEAR, so we convert time to years. # Time unit: Year n_total <- 200 enroll_duration <- 1 # 1 year max_followup <- 1 # 1 year  enroll_rate <- data.frame(   rate = n_total / enroll_duration,   duration = enroll_duration )  fail_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.5, 0.35), # Events per year   dispersion = c(0.5, 0.5) # Negative binomial dispersion )  dropout_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.05, 0.05),   duration = c(100, 100) )"},{"path":"https://keaven.github.io/gsDesignNB/articles/completers-interim-example.html","id":"simulation-loop","dir":"Articles","previous_headings":"","what":"Simulation loop","title":"Group sequential simulation with completers analysis","text":"simulate 50 trials. trial, perform interim final analyses.","code":"set.seed(2024) n_sims <- 50 results <- data.frame(   sim_id = integer(n_sims),   interim_date = numeric(n_sims),   interim_z = numeric(n_sims),   interim_n = integer(n_sims),   interim_info = numeric(n_sims),   final_date = numeric(n_sims),   final_z = numeric(n_sims),   final_n = integer(n_sims),   final_info = numeric(n_sims),   info_frac = numeric(n_sims) )  # Target completers for interim (40%) target_completers <- 0.4 * n_total  for (i in 1:n_sims) {   # 1. Simulate Trial Data   sim_data <- nb_sim(     enroll_rate = enroll_rate,     fail_rate = fail_rate,     dropout_rate = dropout_rate,     max_followup = max_followup,     n = n_total   )    # 2. Interim Analysis   # Find date when target_completers is reached   interim_date <- cut_date_for_completers(sim_data, target_completers)    # Cut data for completers at this date   data_interim <- cut_completers(sim_data, interim_date)    # Analyze (Mütze Test)   res_interim <- mutze_test(data_interim)   # Extract Z-statistic   z_interim <- res_interim$z   # Extract Information   info_interim <- 1 / res_interim$se^2    # 3. Final Analysis (All Data)   # Date is when last patient completes (or max follow-up reached)   # For final analysis, we use all data collected up to the end of the study.   # The end of the study is when the last patient reaches max_followup.   date_final <- max(sim_data$calendar_time)    # Cut data at final date (includes partial follow-up for dropouts, full for completers)   data_final <- cut_data_by_date(sim_data, date_final)    res_final <- mutze_test(data_final)   z_final <- res_final$z   # Extract Information   info_final <- 1 / res_final$se^2    # Store results   results$sim_id[i] <- i   results$interim_date[i] <- interim_date   results$interim_z[i] <- z_interim   results$interim_n[i] <- nrow(data_interim)   results$interim_info[i] <- info_interim   results$final_date[i] <- date_final   results$final_z[i] <- z_final   results$final_n[i] <- nrow(data_final)   results$final_info[i] <- info_final   results$info_frac[i] <- info_interim / info_final }  # Compute asymptotic information # Interim info_asymp_interim <- compute_info_at_time(   analysis_time = mean(results$interim_date),   accrual_rate = n_total / enroll_duration,   accrual_duration = enroll_duration,   lambda1 = fail_rate$rate[1],   lambda2 = fail_rate$rate[2],   dispersion = fail_rate$dispersion[1],   ratio = 1,   dropout_rate = dropout_rate$rate[1] # Assuming equal dropout )  # Final info_asymp_final <- compute_info_at_time(   analysis_time = mean(results$final_date),   accrual_rate = n_total / enroll_duration,   accrual_duration = enroll_duration,   lambda1 = fail_rate$rate[1],   lambda2 = fail_rate$rate[2],   dispersion = fail_rate$dispersion[1],   ratio = 1,   dropout_rate = dropout_rate$rate[1] )  cat(\"Asymptotic Information (Interim):\", round(info_asymp_interim, 2), \"\\n\") #> Asymptotic Information (Interim): 15.54 cat(\"Mean Simulated Information (Interim):\", round(mean(results$interim_info), 2), \"\\n\") #> Mean Simulated Information (Interim): 14.45 cat(\"Asymptotic Information (Final):\", round(info_asymp_final, 2), \"\\n\") #> Asymptotic Information (Final): 22.81 cat(\"Mean Simulated Information (Final):\", round(mean(results$final_info), 2), \"\\n\") #> Mean Simulated Information (Final): 17.29"},{"path":"https://keaven.github.io/gsDesignNB/articles/completers-interim-example.html","id":"results-summary","dir":"Articles","previous_headings":"","what":"Results summary","title":"Group sequential simulation with completers analysis","text":"summarize distribution test statistics (Z-scores) interim final analyses.","code":"summary(results[, c(\"interim_date\", \"interim_z\", \"interim_info\", \"final_date\", \"final_z\", \"final_info\", \"info_frac\")]) #>   interim_date     interim_z        interim_info     final_date    #>  Min.   :1.310   Min.   :-3.3950   Min.   : 9.10   Min.   :1.877   #>  1st Qu.:1.387   1st Qu.:-2.2002   1st Qu.:13.10   1st Qu.:1.950   #>  Median :1.406   Median :-1.3360   Median :14.05   Median :1.983   #>  Mean   :1.416   Mean   :-1.3850   Mean   :14.45   Mean   :1.992   #>  3rd Qu.:1.445   3rd Qu.:-0.8207   3rd Qu.:15.57   3rd Qu.:2.029   #>  Max.   :1.544   Max.   : 1.3095   Max.   :21.56   Max.   :2.173   #>     final_z          final_info      info_frac      #>  Min.   :-3.8041   Min.   :10.57   Min.   :0.7213   #>  1st Qu.:-2.1767   1st Qu.:15.76   1st Qu.:0.7930   #>  Median :-1.5857   Median :17.01   Median :0.8301   #>  Mean   :-1.5420   Mean   :17.29   Mean   :0.8361   #>  3rd Qu.:-0.8692   3rd Qu.:19.04   3rd Qu.:0.8703   #>  Max.   : 1.3956   Max.   :24.31   Max.   :0.9479"},{"path":"https://keaven.github.io/gsDesignNB/articles/completers-interim-example.html","id":"visualization","dir":"Articles","previous_headings":"Results summary","what":"Visualization","title":"Group sequential simulation with completers analysis","text":"Comparison Z-scores Interim vs Final Analysis.  plot shows correlation interim statistic (based 40% completers) final statistic.","code":"# Correlation between interim and final Z-scores cor_z <- cor(results$interim_z, results$final_z) cat(\"Correlation between interim and final Z-scores:\", round(cor_z, 3), \"\\n\") #> Correlation between interim and final Z-scores: 0.929  ggplot(results, aes(x = interim_z, y = final_z)) +   geom_point(alpha = 0.7) +   geom_abline(intercept = 0, slope = 1, linetype = \"dashed\", color = \"gray\") +   labs(     title = paste0(\"Z-Scores: Interim vs Final Analysis (Cor = \", round(cor_z, 3), \")\"),     x = \"Interim Z-Score\",     y = \"Final Z-Score (Full Data)\"   ) +   theme_minimal()"},{"path":"https://keaven.github.io/gsDesignNB/articles/completers-interim-example.html","id":"group-sequential-design-evaluation","dir":"Articles","previous_headings":"Results summary","what":"Group sequential design evaluation","title":"Group sequential simulation with completers analysis","text":"can evaluate operating characteristics design using simulated Z-scores information fractions. assume O’Brien-Fleming spending function upper bound.","code":"# Define design parameters alpha <- 0.025 k <- 2 sfu <- sfLDOF # Lan-DeMets O'Brien-Fleming approximation  # Calculate bounds for each simulation based on observed information fraction # Note: In practice, bounds are often fixed or recalculated. Here we check rejection rates. # We'll use the mean information fraction to set a single boundary for simplicity in this summary, # or we could check each trial individually. Let's check individually.  reject <- logical(n_sims) for (i in 1:n_sims) {   # Compute boundary for interim   # We need to spend alpha based on info_frac[i]   # Using gsDesign to get the boundary   # We want to spend alpha(t) = alpha * sf(t)   # But standard group sequential design defines boundaries.    # Let's use a simple error spending approach:   # Spend alpha_1 at interim based on info_frac[i]   # Spend remaining alpha at final (total alpha = 0.025)    # Interim spending   spend_interim <- sfu(alpha, t = results$info_frac[i])$spend   # Interim bound (Z-scale)   # P(Z > b1) = spend_interim   b1 <- qnorm(1 - spend_interim)    # Check interim rejection   if (results$interim_z[i] > b1) {     reject[i] <- TRUE   } else {     # Final analysis     # We need to find b2 such that P(Z1 < b1, Z2 > b2) = alpha - spend_interim     # This requires integration over the joint distribution.     # For simplicity in this vignette, we can use the asymptotic correlation     # Cor(Z1, Z2) = sqrt(info_frac)      # Using gsDesign to compute the exact boundary given the fraction     # We create a design with this fraction     gs_des <- gsDesign(k = 2, test.type = 1, alpha = alpha, sfu = sfu, timing = results$info_frac[i])     b2 <- gs_des$upper$bound[2]      if (results$final_z[i] > b2) {       reject[i] <- TRUE     }   } }  cat(\"Power (Empirical Rejection Rate):\", mean(reject), \"\\n\") #> Power (Empirical Rejection Rate): 0"},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"trial-design-parameters","dir":"Articles","previous_headings":"","what":"Trial design parameters","title":"Group sequential design and simulation","text":"design trial following characteristics: Enrollment: 12 months constant rate Trial Duration: 24 months Interim 1: 10 months Interim 2: 18 months Final: 24 months Control: 0.125 events per month (1.5 per year) Experimental: 0.0833 events per month (1.0 per year; rate ratio = 0.67) Dispersion: 0.5 Power: 90% (beta = 0.1) Alpha: 0.025 (one-sided) # event gap: 20 days # dropout rate: 5% 1 year # max followup: 12 months","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"sample-size-calculation","dir":"Articles","previous_headings":"Trial design parameters","what":"Sample size calculation","title":"Group sequential design and simulation","text":"First, calculate required sample size fixed design:","code":"# Sample size calculation # Enrollment: constant rate over 12 months # Trial duration: 24 months event_gap_val <- 20 / 30.4375 # Minimum gap between events is 20 days (approx)  nb_ss <- sample_size_nbinom(   lambda1 = 1.5 / 12, # Control event rate (per month)   lambda2 = 1.0 / 12, # Experimental event rate (per month)   dispersion = 0.5, # Overdispersion parameter   power = 0.9, # 90% power   alpha = 0.025, # One-sided alpha   accrual_rate = 100 / 12, # Patients per month (will determine total n)   accrual_duration = 12, # 12 months enrollment   trial_duration = 24, # 24 months trial   max_followup = 12, # 12 months of follow-up per patient   dropout_rate = -log(0.95) / 12, # 5% dropout rate at 1 year   event_gap = event_gap_val,   method = \"zhu\" # Zhu and Lakkis sample size method )  # Print key results cat(\"Fixed design\\n\") #> Fixed design nb_ss #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          zhu #> Sample size:     n1 = 182, n2 = 182, total = 364 #> Expected events: 414.1 (n1: 245.9, n2: 168.2) #> Power: 90%, Alpha: 0.025 (1-sided) #> Rates: control = 0.1250, treatment = 0.0833 (RR = 0.6667) #> Dispersion: 0.5000, Avg exposure (calendar): 11.70 #> Avg exposure (at-risk): n1 = 10.81, n2 = 11.09 #> Event gap: 0.66 #> Dropout rate: 0.0043 #> Accrual: 12.0, Trial duration: 24.0 #> Max follow-up: 12.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"group-sequential-design","dir":"Articles","previous_headings":"Trial design parameters","what":"Group sequential design","title":"Group sequential design and simulation","text":"Now convert group sequential design 3 analyses 10, 18 24 months. Note final analysis time must fixed design. relative enrollment rates increased increase sample size standard group sequential design theory. specify usTime = c(0.1, 0.14, 1) along sfLinear() spending function spend 10%, 14% 100% cumulative α\\alpha 3 planned analyses regardless observed statistical information analysis. Textual group sequential design summary: Tabular summary:","code":"# Analysis times (in months) analysis_times <- c(10, 18, 24)  # Create group sequential design with integer sample sizes gs_nb <- gsNBCalendar(   x = nb_ss, # Input fixed design for negative binomial   k = 3, # 3 analyses   test.type = 4, # Two-sided asymmetric, non-binding futility   sfu = sfLinear, # Linear spending function for upper bound   sfupar = c(.5, .5), # Identity function   sfl = sfHSD, # HSD spending for lower bound   sflpar = -8, # Conservative futility bound   usTime = c(.1, .14, 1), # Upper spending timing   lsTime = NULL, # Spending based on information   analysis_times = analysis_times # Calendar times in months ) |> gsDesignNB::toInteger() # Round to integer sample size summary(gs_nb) #> Asymmetric two-sided with non-binding futility bound group sequential design #> for negative binomial outcomes, 3 analyses, total sample size 370.0, 90 percent #> power, 2.5 percent (1-sided) Type I error. Control rate 0.1250, treatment rate #> 0.0833, risk ratio 0.6667, dispersion 0.5000. Accrual duration 12.0, trial #> duration 24.0, max follow-up 12.0, event gap 0.66, dropout rate 0.0043, average #> exposure (calendar) 11.70, (at-risk n1=10.81, n2=11.09). Randomization ratio #> 1:1. gs_nb |>   gsDesign::gsBoundSummary(     deltaname = \"RR\",     logdelta = TRUE,     Nname = \"Information\",     timename = \"Month\",     digits = 4,     ddigits = 2   ) |>   gt() |>   tab_header(     title = \"Group Sequential Design Bounds for Negative Binomial Outcome\",     subtitle = paste0(       \"N = \", ceiling(gs_nb$n_total[gs_nb$k]),       \", Expected events = \", round(gs_nb$nb_design$total_events, 1)     )   )"},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"simulation-study","dir":"Articles","previous_headings":"","what":"Simulation study","title":"Group sequential design and simulation","text":"now simulate 50 trials evaluate power group sequential design assuming design parameters correct.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"simulation-setup","dir":"Articles","previous_headings":"Simulation study","what":"Simulation setup","title":"Group sequential design and simulation","text":"","code":"set.seed(42) n_sims <- 50  # Enrollment rate (patients per month) to achieve target sample size n_target <- ceiling(nb_ss$n_total) enroll_rate_val <- n_target / 12 # All enrolled in 12 months  # Define enrollment enroll_rate <- data.frame(   rate = enroll_rate_val,   duration = 12 # 12 months enrollment )  # Define failure rates (with dispersion) fail_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(1.5 / 12, 1.0 / 12),   dispersion = c(0.5, 0.5) )  # Dropout rate (5% at 1 year) dropout_rate_val <- -log(0.95) dropout_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(dropout_rate_val, dropout_rate_val),   duration = c(100, 100) # Long duration )  # Maximum follow-up (trial duration from enrollment start) max_followup <- 12 # 12 months to match design"},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"run-simulations","dir":"Articles","previous_headings":"Simulation study","what":"Run simulations","title":"Group sequential design and simulation","text":"","code":"# Storage for results results <- vector(\"list\", n_sims)  for (sim in 1:n_sims) {   # Simulate trial data   sim_data <- nb_sim(     enroll_rate = enroll_rate,     fail_rate = fail_rate,     dropout_rate = dropout_rate,     max_followup = max_followup,     n = n_target   )    # Analyze at each interim   sim_results <- data.frame(     sim = sim,     analysis = 1:3,     analysis_time = analysis_times,     n_enrolled = NA_integer_,     events_ctrl = NA_integer_,     events_exp = NA_integer_,     events_total = NA_integer_,     exposure_ctrl = NA_real_,     exposure_exp = NA_real_,     blinded_info = NA_real_,     unblinded_info = NA_real_,     z_stat = NA_real_,     p_value = NA_real_,     cross_upper = NA,     cross_lower = NA   )    stopped <- FALSE    for (k in 1:3) {     if (stopped) {       # Trial already stopped at earlier analysis       sim_results$cross_upper[k] <- FALSE       sim_results$cross_lower[k] <- FALSE       next     }      # Cut data at analysis time     cut_time <- analysis_times[k]     cut_data <- cut_data_by_date(sim_data, cut_date = cut_time, event_gap = event_gap_val)      # Count enrolled subjects (those with enroll_time <= cut_time)     enrolled <- unique(sim_data$id[sim_data$enroll_time <= cut_time])     cut_data <- cut_data[cut_data$id %in% enrolled, ]      # Summary by treatment     summary_dt <- as.data.table(cut_data)[       ,       .(n = .N, events = sum(events), exposure = sum(tte)),       by = treatment     ]      ctrl_row <- summary_dt[treatment == \"Control\"]     exp_row <- summary_dt[treatment == \"Experimental\"]      sim_results$n_enrolled[k] <- nrow(cut_data)     sim_results$events_ctrl[k] <- if (nrow(ctrl_row) > 0) ctrl_row$events else 0     sim_results$events_exp[k] <- if (nrow(exp_row) > 0) exp_row$events else 0     sim_results$events_total[k] <- sim_results$events_ctrl[k] + sim_results$events_exp[k]     sim_results$exposure_ctrl[k] <- if (nrow(ctrl_row) > 0) ctrl_row$exposure else 0     sim_results$exposure_exp[k] <- if (nrow(exp_row) > 0) exp_row$exposure else 0      # Run Mütze test     if (nrow(cut_data) >= 4 && sim_results$events_total[k] >= 2) {       test_result <- tryCatch(         mutze_test(cut_data),         error = function(e) NULL       )        if (!is.null(test_result)) {         sim_results$z_stat[k] <- test_result$z         sim_results$p_value[k] <- test_result$p_value          # Calculate unblinded information using the variance from the GLM         sim_results$unblinded_info[k] <- 1 / test_result$se^2          # Calculate blinded information and update bounds         blinded_est <- calculate_blinded_info(           cut_data,           ratio = nb_ss$inputs$ratio,           lambda1_planning = nb_ss$inputs$lambda1,           lambda2_planning = nb_ss$inputs$lambda2,           event_gap = event_gap_val         )         sim_results$blinded_info[k] <- blinded_est$blinded_info          # Update design with observed information fraction         max_info <- gs_nb$n.fix         # If observed info >= max info, this must be the final analysis         if (blinded_est$blinded_info >= max_info) {           # Only if not already at the final analysis           if (k < 3) {             # Consider this the final analysis for this simulation             # We need to treat this as if k were the final analysis index             # But the loop structure expects k=3 to be final.             # Effectively, we have reached 100% info early.             frac <- 1           } else {             frac <- 1           }         } else if (k == 3) {           frac <- 1         } else {           frac <- blinded_est$blinded_info / max_info         }          # Current timing         current_timing <- gs_nb$timing         current_timing[k] <- frac          # Safety check for timing order         if (k > 1 && current_timing[k] <= current_timing[k - 1]) current_timing[k] <- current_timing[k - 1] + 0.001          # If we have reached full information early (frac >= 1), adjust timing         if (frac >= 1 && k < 3) {           # Set current timing to 1           current_timing[k] <- 1           # Set subsequent timings to 1 as well (though they won't be reached ideally,           # gsDesign needs valid input)           current_timing[(k + 1):3] <- 1           # Note: gsDesign might complain if timing is 1 at interim.           # Actually gsDesign requires timing to be increasing and < 1 for interims usually.           # If information fraction > 1, we should probably stop the trial.           stopped <- TRUE         }          if (k < 3 && current_timing[k + 1] <= current_timing[k]) {           # Ensure strict monotonicity if not already at 1           if (current_timing[k] < 1) {             current_timing[k + 1] <- min(current_timing[k] + 0.001, 0.999)           }         }          # Recompute bounds         # We only recompute if we haven't exceeded information         if (frac <= 1 || k == 3) {           temp_gs <- gsDesign::gsDesign(             k = 3,             test.type = 4,             alpha = 0.025,             beta = 0.1,             sfu = gsDesign::sfLinear, sfupar = c(.5, .5),             sfl = gsDesign::sfHSD, sflpar = -8,             usTime = c(.1, .18, 1),             timing = current_timing,             n.fix = max_info           )            upper_bound <- temp_gs$upper$bound[k]           lower_bound <- temp_gs$lower$bound[k]            # Check boundaries (one-sided: reject if z < -upper bound for benefit)           # For rate ratio < 1 (experimental better), log(RR) < 0, so z < 0           z_eff <- -test_result$z # Flip sign for efficacy direction            sim_results$cross_upper[k] <- z_eff > upper_bound           sim_results$cross_lower[k] <- z_eff < lower_bound            if (sim_results$cross_upper[k] || sim_results$cross_lower[k]) {             stopped <- TRUE           }         } else {           # Information limit reached early           # We should check against final bound, but technically this is an overrun           # For simplicity here, we stop.           stopped <- TRUE         }       }     }   }    results[[sim]] <- sim_results }  # Combine all results all_results <- do.call(rbind, results)"},{"path":[]},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"events-and-exposure-by-analysis","dir":"Articles","previous_headings":"Simulation results summary","what":"Events and exposure by analysis","title":"Group sequential design and simulation","text":"","code":"# Summarize by analysis summary_by_analysis <- as.data.table(all_results)[   ,   .(     mean_enrolled = mean(n_enrolled, na.rm = TRUE),     mean_events_total = mean(events_total, na.rm = TRUE),     mean_events_ctrl = mean(events_ctrl, na.rm = TRUE),     mean_events_exp = mean(events_exp, na.rm = TRUE),     mean_exposure_ctrl = mean(exposure_ctrl, na.rm = TRUE),     mean_exposure_exp = mean(exposure_exp, na.rm = TRUE),     mean_z = mean(z_stat, na.rm = TRUE),     sd_z = sd(z_stat, na.rm = TRUE)   ),   by = .(analysis, analysis_time) ]  summary_by_analysis |>   gt() |>   tab_header(title = \"Summary Statistics by Analysis\") |>   cols_label(     analysis = \"Analysis\",     analysis_time = \"Time (months)\",     mean_enrolled = \"N Enrolled\",     mean_events_total = \"Total Events\",     mean_events_ctrl = \"Ctrl Events\",     mean_events_exp = \"Exp Events\",     mean_exposure_ctrl = \"Ctrl Exposure\",     mean_exposure_exp = \"Exp Exposure\",     mean_z = \"Mean Z\",     sd_z = \"SD Z\"   ) |>   fmt_number(decimals = 2)"},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"statistical-information","dir":"Articles","previous_headings":"Simulation results summary","what":"Statistical information","title":"Group sequential design and simulation","text":"statistical information analysis proportional precision treatment effect estimate. negative binomial outcomes, relates total exposure event counts. note asymptotic information approximation overstates information analysis. However, power approximation still worked reasonably well. evaluated larger simulation study vignette verification-simulation.Rmd.","code":"# Summarize information (using blinded estimate from simulation) info_by_analysis <- as.data.table(all_results)[   ,   .(     mean_blinded = mean(blinded_info, na.rm = TRUE),     mean_unblinded = mean(unblinded_info, na.rm = TRUE)   ),   by = analysis ]  # Add planned information from design info_by_analysis[, planned_info := gs_nb$n.I[analysis]]  # Normalize to get observed information fractions (relative to planned max) max_planned_info <- tail(gs_nb$n.I, 1) info_by_analysis[, observed_frac_blinded := mean_blinded / max_planned_info] info_by_analysis[, observed_frac_unblinded := mean_unblinded / max_planned_info] info_by_analysis[, planned_info_frac := planned_info / max_planned_info]  info_by_analysis |>   gt() |>   tab_header(title = \"Information by Analysis\") |>   cols_label(     analysis = \"Analysis\",     mean_blinded = \"Mean Info (Blinded)\",     mean_unblinded = \"Mean Info (Unblinded)\",     planned_info = \"Planned Info\",     planned_info_frac = \"Planned Frac\",     observed_frac_blinded = \"Obs Frac (Blind)\",     observed_frac_unblinded = \"Obs Frac (Unblind)\"   ) |>   fmt_number(decimals = 3)"},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"boundary-crossings-and-power","dir":"Articles","previous_headings":"Simulation results summary","what":"Boundary crossings and power","title":"Group sequential design and simulation","text":"","code":"# Calculate crossing probabilities crossing_summary <- as.data.table(all_results)[   ,   .(     n_cross_upper = sum(cross_upper, na.rm = TRUE),     n_cross_lower = sum(cross_lower, na.rm = TRUE),     n_continue = sum(!cross_upper & !cross_lower, na.rm = TRUE)   ),   by = analysis ]  crossing_summary[, prob_cross_upper := n_cross_upper / n_sims] crossing_summary[, prob_cross_lower := n_cross_lower / n_sims]  # Cumulative power (Sim) crossing_summary[, cum_prob_cross_upper := cumsum(prob_cross_upper)]  # Cumulative power (Design) # Drift parameter for alternative: |log(RR)| * sqrt(I_max) # Note: gs_nb$n.fix is the information at final analysis log_rr <- log(nb_ss$inputs$lambda2 / nb_ss$inputs$lambda1) theta <- abs(log_rr) * sqrt(gs_nb$n.fix) design_probs <- gsDesign::gsProbability(d = gs_nb, theta = theta) crossing_summary[, design_cum_power := cumsum(design_probs$upper$prob)[analysis]]  crossing_summary[, .(analysis, n_cross_upper, cum_prob_cross_upper, design_cum_power)] |>   gt() |>   tab_header(title = \"Boundary Crossing and Power\") |>   cols_label(     analysis = \"Analysis\",     n_cross_upper = \"N Cross Upper\",     cum_prob_cross_upper = \"Cum Power (Sim)\",     design_cum_power = \"Cum Power (Design)\"   ) |>   fmt_number(columns = contains(\"power\"), decimals = 3)"},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"overall-power","dir":"Articles","previous_headings":"Simulation results summary","what":"Overall power","title":"Group sequential design and simulation","text":"","code":"# Determine if each simulation crossed the efficacy boundary at any analysis efficacy_by_sim <- as.data.table(all_results)[   ,   .(efficacy = any(cross_upper, na.rm = TRUE)),   by = sim ]  overall_power <- mean(efficacy_by_sim$efficacy, na.rm = TRUE)  # Futility stopping futility_by_sim <- as.data.table(all_results)[   ,   .(futility = any(cross_lower, na.rm = TRUE) & !any(cross_upper, na.rm = TRUE)),   by = sim ]  overall_futility <- mean(futility_by_sim$futility, na.rm = TRUE)  cat(\"\\n=== Overall Operating Characteristics ===\\n\") #>  #> === Overall Operating Characteristics === cat(sprintf(\"Number of simulations: %d\\n\", n_sims)) #> Number of simulations: 50 cat(sprintf(\"Overall Power (P[reject H0]): %.1f%%\\n\", overall_power * 100)) #> Overall Power (P[reject H0]): 86.0% cat(sprintf(\"Futility Stopping Rate: %.1f%%\\n\", overall_futility * 100)) #> Futility Stopping Rate: 14.0% cat(sprintf(\"Design Power (target): %.1f%%\\n\", (1 - gs_nb$beta) * 100)) #> Design Power (target): 90.0%"},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"visualization-of-z-statistics","dir":"Articles","previous_headings":"Simulation results summary","what":"Visualization of Z-statistics","title":"Group sequential design and simulation","text":"","code":"# Prepare data for plotting plot_data <- all_results plot_data$z_flipped <- -plot_data$z_stat # Flip for efficacy direction  # Boundary data bounds_df <- data.frame(   analysis = 1:3,   upper = gs_nb$upper$bound,   lower = gs_nb$lower$bound )  ggplot(plot_data, aes(x = factor(analysis), y = z_flipped)) +   geom_violin(fill = \"steelblue\", alpha = 0.5, color = \"steelblue\") +   geom_boxplot(width = 0.1, fill = \"white\", outlier.shape = NA) +   # Draw bounds as lines connecting analyses   geom_line(     data = bounds_df, aes(x = analysis, y = upper, group = 1),     linetype = \"dashed\", color = \"darkgreen\", linewidth = 1   ) +   geom_line(     data = bounds_df, aes(x = analysis, y = lower, group = 1),     linetype = \"dashed\", color = \"darkred\", linewidth = 1   ) +   # Draw points for bounds   geom_point(data = bounds_df, aes(x = analysis, y = upper), color = \"darkgreen\") +   geom_point(data = bounds_df, aes(x = analysis, y = lower), color = \"darkred\") +   geom_hline(yintercept = 0, color = \"gray50\") +   labs(     title = \"Simulated Z-Statistics by Analysis\",     subtitle = \"Green dashed = efficacy bound, Red dashed = futility bound\",     x = \"Analysis\",     y = \"Z-statistic (positive = favors experimental)\"   ) +   theme_minimal() +   ylim(c(-4, 6)) #> Warning: Removed 44 rows containing non-finite outside the scale range #> (`stat_ydensity()`). #> Warning: Removed 44 rows containing non-finite outside the scale range #> (`stat_boxplot()`)."},{"path":"https://keaven.github.io/gsDesignNB/articles/group-sequential-simulation.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Group sequential design and simulation","text":"simulation demonstrates basic workflow group sequential designs negative binomial outcomes: Sample size calculation using sample_size_nbinom() fixed design Group sequential design using gsNBCalendar() add interim analyses Simulation using nb_sim() generate trial data Analysis using cut_data_by_date() mutze_test() interim Boundary checking group sequential bounds usTime = c(0.1, 0.2, 1) specification provides conservative alpha spending early analyses, preserving Type error later analyses information available. 50 simulations, estimated power substantial Monte Carlo error. precise estimates, increase n_sims 1000 .","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"methodology","dir":"Articles","previous_headings":"","what":"Methodology","title":"Sample size calculation for negative binomial outcomes","text":"assume outcome YY follows negative binomial distribution mean μ\\mu dispersion parameter kk, variance given : Var(Y)=μ+kμ2 Var(Y) = \\mu + k \\mu^2 Note R’s rnbinom parameterization, k=1/𝚜𝚒𝚣𝚎k = 1/\\texttt{size}. wish test null hypothesis H0:λ1=λ2H_0: \\lambda_1 = \\lambda_2 alternative H1:λ1≠λ2H_1: \\lambda_1 \\neq \\lambda_2, λ1\\lambda_1 λ2\\lambda_2 event rates control treatment groups, respectively. function implements two methods:","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"method-1-zhu-and-lakkis-2014","dir":"Articles","previous_headings":"Methodology","what":"Method 1: Zhu and Lakkis (2014)","title":"Sample size calculation for negative binomial outcomes","text":"method based asymptotic normality log rate ratio. sample size control group (n1n_1) : n1=(zα/s+zβ)2⋅V(log(μ1/μ2))2 n_1 = \\frac{(z_{\\alpha/s} + z_{\\beta})^2 \\cdot V}{(\\log(\\mu_1/\\mu_2))^2} VV variance component: V=(1μ1+k)+1r(1μ2+k) V = \\left(\\frac{1}{\\mu_1} + k\\right) + \\frac{1}{r}\\left(\\frac{1}{\\mu_2} + k\\right) r=n2/n1r = n_2/n_1 allocation ratio, μi=λi⋅t\\mu_i = \\lambda_i \\cdot t expected mean count exposure duration tt.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"method-2-friede-and-schmidli-2010-mütze-et-al--2018","dir":"Articles","previous_headings":"Methodology","what":"Method 2: Friede and Schmidli (2010) / Mütze et al. (2018)","title":"Sample size calculation for negative binomial outcomes","text":"method uses Wald test statistic commonly used group sequential designs (implemented gscounts package). total sample size ntotaln_{total} calculated : ntotal=(zα/s+zβ)2⋅V‾(log(λ1/λ2))2 n_{total} = \\frac{(z_{\\alpha/s} + z_{\\beta})^2 \\cdot \\bar{V}}{(\\log(\\lambda_1/\\lambda_2))^2} V‾\\bar{V} average variance per subject: V‾=1/μ1+kp1+1/μ2+kp2 \\bar{V} = \\frac{1/ \\mu_1 + k}{p_1} + \\frac{1/ \\mu_2 + k}{p_2} p1=n1/ntotalp_1 = n_1/n_{total} p2=n2/ntotalp_2 = n_2/n_{total} allocation proportions. Note: fixed design equal allocation, methods yield identical sample sizes.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"average-exposure-with-variable-accrual-and-dropout","dir":"Articles","previous_headings":"","what":"Average exposure with variable accrual and dropout","title":"Sample size calculation for negative binomial outcomes","text":"accrual rate constant trial fixed duration ongoing recruitment, exposure time patients vary. function calculates average exposure time use sample size formula. Additionally, dropout_rate specified, exposure adjusted account patients leaving study early. Let TT total trial duration. Suppose recruitment occurs JJ segments, jj-th segment accrual rate RjR_j duration DjD_j. dropout_rate 0: expected number patients recruited segment jj Nj=Rj⋅DjN_j = R_j \\cdot D_j. start time segment jj Sj−1=∑=1j−1DiS_{j-1} = \\sum_{=1}^{j-1} D_i (S0=0S_0 = 0). midpoint recruitment segment jj Mj=Sj−1+Dj/2M_j = S_{j-1} + D_j/2. average follow-(exposure) time patients recruited segment jj approximately Ej=T−MjE_j = T - M_j. dropout_rate (δ\\delta) > 0, average exposure calculated integrating exposure function recruitment interval: Ej=1Dj∫uminumax1−e−δuδdu=1δ−1δ2Dj(e−δumin−e−δumax) \\begin{aligned} E_j &= \\frac{1}{D_j}\\int_{u_{min}}^{u_{max}} \\frac{1 - e^{-\\delta u}}{\\delta} du \\\\ &= \\frac{1}{\\delta} - \\frac{1}{\\delta^2 D_j} \\left( e^{-\\delta u_{min}} - e^{-\\delta u_{max}} \\right) \\end{aligned}  umaxu_{max} uminu_{min} maximum minimum potential follow-times patients segment (T−Sj−1T - S_{j-1} T−(Sj−1+Dj)T - (S_{j-1} + D_j) respectively).","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"maximum-follow-up","dir":"Articles","previous_headings":"Average exposure with variable accrual and dropout","what":"Maximum follow-up","title":"Sample size calculation for negative binomial outcomes","text":"max_followup (FF) specified, follow-time individual capped FF. creates three scenarios recruitment segment: truncated: umin≥Fu_{min} \\ge F, patients segment potential follow-≥F\\ge F, actual follow-FF (subject dropout). None truncated: umax≤Fu_{max} \\le F, patients reach cap FF trial ends. calculation . Partial truncation: umin<F<umaxu_{min} < F < u_{max}, patients recruited earlier segment capped FF, recruited later followed trial end. segment split two parts calculation. overall average exposure used calculation weighted average: t‾=∑j=1JNjEj∑j=1JNj \\bar{t} = \\frac{\\sum_{j=1}^J N_j E_j}{\\sum_{j=1}^J N_j}","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"variance-inflation-for-variable-follow-up","dir":"Articles","previous_headings":"Average exposure with variable accrual and dropout","what":"Variance inflation for variable follow-up","title":"Sample size calculation for negative binomial outcomes","text":"follow-times variable (due accrual, dropout, administrative censoring), simply using average follow-time t‾\\bar{t} variance formula underestimates true variance rate estimator. variance negative binomial distribution depends exposure time non-linear way (Var(Y)=μ+kμ2=λt+k(λt)2Var(Y) = \\mu + k\\mu^2 = \\lambda t + k (\\lambda t)^2). account , apply variance inflation factor QQ dispersion parameter kk, derived Zhu Lakkis (2014): Q=E[t2](E[t])2 Q = \\frac{E[t^2]}{(E[t])^2} adjusted dispersion parameter used sample size calculation kadj=k⋅Qk_{adj} = k \\cdot Q. function automatically calculates E[t]E[t] E[t2]E[t^2] based accrual, dropout, trial duration parameters.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"event-gaps","dir":"Articles","previous_headings":"Average exposure with variable accrual and dropout","what":"Event gaps","title":"Sample size calculation for negative binomial outcomes","text":"clinical trials, mandatory “dead time” gap event new events can occur (e.g., recovery period). event_gap specified, effective exposure time subject reduced time spent gaps. function approximates effective event rate : λeff≈λ1+λ⋅gap \\lambda_{eff} \\approx \\frac{\\lambda}{1 + \\lambda \\cdot \\text{gap}}  adjusted rate used sample size calculations. effective exposure time reported also adjusted similarly.","code":""},{"path":[]},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"basic-calculation-zhu-and-lakkis","dir":"Articles","previous_headings":"Examples","what":"Basic calculation (Zhu and Lakkis)","title":"Sample size calculation for negative binomial outcomes","text":"Calculate sample size : Control rate λ1=0.5\\lambda_1 = 0.5 Treatment rate λ2=0.3\\lambda_2 = 0.3 Dispersion k=0.1k = 0.1 Power = 80% Alpha = 0.025 (one-sided) Accrual 12 months Trial duration 12 months (implying exposure approx 6 months)","code":"sample_size_nbinom(   lambda1 = 0.5,   lambda2 = 0.3,   dispersion = 0.1,   power = 0.8,   alpha = 0.025,   sided = 1,   accrual_rate = 10, # arbitrary, just for average exposure   accrual_duration = 12,   trial_duration = 12,   method = \"zhu\" ) #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          zhu #> Sample size:     n1 = 35, n2 = 35, total = 70 #> Expected events: 168.0 (n1: 105.0, n2: 63.0) #> Power: 80%, Alpha: 0.025 (1-sided) #> Rates: control = 0.5000, treatment = 0.3000 (RR = 0.6000) #> Dispersion: 0.1000, Avg exposure (calendar): 6.00 #> Accrual: 12.0, Trial duration: 12.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"using-friede-et-al--method","dir":"Articles","previous_headings":"Examples","what":"Using Friede et al. method","title":"Sample size calculation for negative binomial outcomes","text":"","code":"sample_size_nbinom(   lambda1 = 0.5,   lambda2 = 0.3,   dispersion = 0.1,   power = 0.8,   alpha = 0.025,   sided = 1,   accrual_rate = 10,   accrual_duration = 12,   trial_duration = 12,   method = \"friede\" ) #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          friede #> Sample size:     n1 = 35, n2 = 35, total = 70 #> Expected events: 168.0 (n1: 105.0, n2: 63.0) #> Power: 80%, Alpha: 0.025 (1-sided) #> Rates: control = 0.5000, treatment = 0.3000 (RR = 0.6000) #> Dispersion: 0.1000, Avg exposure (calendar): 6.00 #> Accrual: 12.0, Trial duration: 12.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"piecewise-constant-accrual","dir":"Articles","previous_headings":"Examples","what":"Piecewise constant accrual","title":"Sample size calculation for negative binomial outcomes","text":"Consider trial recruitment ramps : 5 patients/month first 3 months 10 patients/month next 3 months Total trial duration 12 months function automatically calculates average exposure based accrual pattern.","code":"sample_size_nbinom(   lambda1 = 0.5,   lambda2 = 0.3,   dispersion = 0.1,   power = 0.8,   accrual_rate = c(5, 10),   accrual_duration = c(3, 3),   trial_duration = 12 ) #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          zhu #> Sample size:     n1 = 26, n2 = 26, total = 52 #> Expected events: 176.8 (n1: 110.5, n2: 66.3) #> Power: 80%, Alpha: 0.025 (1-sided) #> Rates: control = 0.5000, treatment = 0.3000 (RR = 0.6000) #> Dispersion: 0.1000, Avg exposure (calendar): 8.50 #> Accrual: 6.0, Trial duration: 12.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"accrual-with-dropout-and-max-follow-up","dir":"Articles","previous_headings":"Examples","what":"Accrual with dropout and max follow-up","title":"Sample size calculation for negative binomial outcomes","text":"design , 5% dropout rate per unit time maximum follow-6 months.","code":"sample_size_nbinom(   lambda1 = 0.5,   lambda2 = 0.3,   dispersion = 0.1,   power = 0.8,   accrual_rate = c(5, 10),   accrual_duration = c(3, 3),   trial_duration = 12,   dropout_rate = 0.05,   max_followup = 6 ) #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          zhu #> Sample size:     n1 = 38, n2 = 38, total = 76 #> Expected events: 157.6 (n1: 98.5, n2: 59.1) #> Power: 80%, Alpha: 0.025 (1-sided) #> Rates: control = 0.5000, treatment = 0.3000 (RR = 0.6000) #> Dispersion: 0.1000, Avg exposure (calendar): 5.18 #> Dropout rate: 0.0500 #> Accrual: 6.0, Trial duration: 12.0 #> Max follow-up: 6.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"calculating-power-for-fixed-design","dir":"Articles","previous_headings":"Examples","what":"Calculating power for fixed design","title":"Sample size calculation for negative binomial outcomes","text":"Using accrual rates design previous example, suppose want calculate power treatment effect smaller (λ2=0.4\\lambda_2 = 0.4 instead 0.30.3). use accrual_rate computed previous step.","code":"# Store the result from the previous calculation design_result <- sample_size_nbinom(   lambda1 = 0.5,   lambda2 = 0.3,   dispersion = 0.1,   power = 0.8,   accrual_rate = c(5, 10),   accrual_duration = c(3, 3),   trial_duration = 12,   dropout_rate = 0.05,   max_followup = 6 )  # Use the computed accrual rates to calculate power for a smaller effect size sample_size_nbinom(   lambda1 = 0.5,   lambda2 = 0.4, # Smaller effect size   dispersion = 0.1,   power = NULL, # Request power calculation   accrual_rate = design_result$accrual_rate, # Use computed rates   accrual_duration = c(3, 3),   trial_duration = 12,   dropout_rate = 0.05,   max_followup = 6 ) #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          zhu #> Sample size:     n1 = 38, n2 = 38, total = 76 #> Expected events: 177.3 (n1: 98.5, n2: 78.8) #> Power: 26%, Alpha: 0.025 (1-sided) #> Rates: control = 0.5000, treatment = 0.4000 (RR = 0.8000) #> Dispersion: 0.1000, Avg exposure (calendar): 5.18 #> Dropout rate: 0.0500 #> Accrual: 6.0, Trial duration: 12.0 #> Max follow-up: 6.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"unequal-allocation","dir":"Articles","previous_headings":"Examples","what":"Unequal allocation","title":"Sample size calculation for negative binomial outcomes","text":"Sample size 2:1 allocation ratio (n2=2n1n_2 = 2 n_1).","code":"sample_size_nbinom(   lambda1 = 0.5,   lambda2 = 0.3,   dispersion = 0.1,   ratio = 2,   accrual_rate = 10,   accrual_duration = 12,   trial_duration = 12 ) #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          zhu #> Sample size:     n1 = 40, n2 = 80, total = 120 #> Expected events: 264.0 (n1: 120.0, n2: 144.0) #> Power: 95%, Alpha: 0.025 (1-sided) #> Rates: control = 0.5000, treatment = 0.3000 (RR = 0.6000) #> Dispersion: 0.1000, Avg exposure (calendar): 6.00 #> Accrual: 12.0, Trial duration: 12.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"accounting-for-event-gaps","dir":"Articles","previous_headings":"","what":"Accounting for event gaps","title":"Sample size calculation for negative binomial outcomes","text":"recurrent event trials, may mandatory “gap” period event new events can recorded (e.g., recovery period administrative window). effectively reduces time risk. event_gap (gg) specified, function adjusts calculation follows: Effective Rates: event rates adjusted λ*=λ/(1+λg)\\lambda^* = \\lambda / (1 + \\lambda g) sample size calculation (Zhu Lakkis method). -Risk Exposure: function reports “average -risk exposure” Erisk=Ecal/(1+λg)E_{risk} = E_{cal} / (1 + \\lambda g) alongside standard calendar exposure. provides transparency actual time subjects risk events. Since gap reduction depends event rate (λ\\lambda), -risk exposure differs treatment groups rates differ.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"example-with-event-gap","dir":"Articles","previous_headings":"Accounting for event gaps","what":"Example with event gap","title":"Sample size calculation for negative binomial outcomes","text":"Calculate sample size assuming 5-day gap event (approx 0.0137 years). output shows “Avg exposure (calendar)” “Avg exposure (-risk)” group.","code":"sample_size_nbinom(   lambda1 = 0.5,   lambda2 = 0.3,   dispersion = 0.1,   power = 0.8,   accrual_rate = 10,   accrual_duration = 12,   trial_duration = 12,   event_gap = 5 / 365.25 ) #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          zhu #> Sample size:     n1 = 35, n2 = 35, total = 70 #> Expected events: 167.0 (n1: 104.3, n2: 62.7) #> Power: 80%, Alpha: 0.025 (1-sided) #> Rates: control = 0.5000, treatment = 0.3000 (RR = 0.6000) #> Dispersion: 0.1000, Avg exposure (calendar): 6.00 #> Avg exposure (at-risk): n1 = 5.96, n2 = 5.98 #> Event gap: 0.01 #> Accrual: 12.0, Trial duration: 12.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/sample-size-nbinom.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Sample size calculation for negative binomial outcomes","text":"Zhu, H., & Lakkis, H. (2014). Sample size calculation comparing two negative binomial rates clinical trials. Statistics Biopharmaceutical Research, 6(1), 107-115. https://doi.org/10.1080/19466315.2013.870533 Friede, T., & Schmidli, H. (2010). Sample size estimation clinical trials negative binomial rates. Methods Information Medicine, 49(6), 623-631. https://doi.org/10.3414/ME09-01-0058 Mütze, T., Glimm, E., Schmidli, H., & Friede, T. (2018). Group sequential designs negative binomial outcomes. Statistical Methods Medical Research, 27(10), 2978-2993. https://doi.org/10.1177/0962280218773115","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/seasonal-simulation.html","id":"simulation-setup","dir":"Articles","previous_headings":"","what":"Simulation setup","title":"Seasonal event simulation","text":"design small trial following characteristics: Randomization Start: January 1, 2024. Sample Size: 20 subjects. Enrollment: 6 months duration. Follow-: 1 year. Seasonality: Higher event rates Winter/Fall, lower Spring/Summer.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/seasonal-simulation.html","id":"define-parameters","dir":"Articles","previous_headings":"Simulation setup","what":"Define parameters","title":"Seasonal event simulation","text":"","code":"# Randomization starts in Winter rand_start <- as.Date(\"2024-01-01\")  # Enrollment: 20 subjects over 6 months enroll_rate <- data.frame(   rate = 20 / 6,   duration = 6 ) # time unit: months? # Note: In nb_sim_seasonal, we assumed rate units match max_followup units. # Let's use YEARS as the time unit for consistency with the package conventions often used. # If max_followup = 1 (year), then rates are per year. # Enrollment duration = 0.5 years.  enroll_rate <- data.frame(   rate = 20 / 0.5,   duration = 0.5 )  # Seasonal Failure Rates (per year) # Winter: High # Spring: Low # Summer: Low # Fall: Medium-High  fail_rate <- data.frame(   treatment = rep(c(\"Control\", \"Experimental\"), each = 4),   season = rep(c(\"Winter\", \"Spring\", \"Summer\", \"Fall\"), 2),   rate = c(     # Control     2.0, # Winter     0.5, # Spring     0.2, # Summer     1.5, # Fall     # Experimental (assume 30% reduction)     2.0 * 0.7,     0.5 * 0.7,     0.2 * 0.7,     1.5 * 0.7   ),   dispersion = 0.5 # Constant dispersion )  # Dropout (5% per year) dropout_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.05, 0.05),   duration = c(100, 100) )"},{"path":"https://keaven.github.io/gsDesignNB/articles/seasonal-simulation.html","id":"run-simulation","dir":"Articles","previous_headings":"","what":"Run simulation","title":"Seasonal event simulation","text":"use nb_sim_seasonal() simulate trial. output contains multiple rows per subject, split season intervals. event 1 event occurred end interval, 0 otherwise.","code":"set.seed(123)  sim_data <- nb_sim_seasonal(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   dropout_rate = dropout_rate,   max_followup = 1, # 1 year   randomization_start_date = rand_start,   n = 20 )  # View structure of the output head(sim_data) #>   id treatment enroll_time season     start       end event  cal_start #> 1  1   Control  0.02108643 Winter 0.0000000 0.1431846     0 2024-01-08 #> 2  1   Control  0.02108643 Spring 0.1431846 0.3950669     0 2024-03-01 #> 3  1   Control  0.02108643 Summer 0.3950669 0.6469492     0 2024-06-01 #> 4  1   Control  0.02108643   Fall 0.6469492 0.8446997     1 2024-09-01 #> 5  1   Control  0.02108643   Fall 0.8446997 0.8960936     0 2024-11-12 #> 6  1   Control  0.02108643 Winter 0.8960936 1.0000000     0 2024-12-01 #>      cal_end #> 1 2024-03-01 #> 2 2024-06-01 #> 3 2024-09-01 #> 4 2024-11-12 #> 5 2024-12-01 #> 6 2025-01-07"},{"path":"https://keaven.github.io/gsDesignNB/articles/seasonal-simulation.html","id":"analysis-at-a-cut-date","dir":"Articles","previous_headings":"","what":"Analysis at a cut date","title":"Seasonal event simulation","text":"can cut data specific calendar date using cut_data_by_date(). function aggregates seasonal intervals cut date, subtracting event gaps specified. analysis_data aggregated subject season. allows seasonal adjustments analysis desired.","code":"# Cut data at 9 months (0.75 years) cut_date <- 0.75  # Use a small gap (e.g., 7 days) gap_days <- 7 / 365.25  analysis_data <- cut_data_by_date(sim_data, cut_date = cut_date, event_gap = gap_days)  head(analysis_data) #>   id    treatment enroll_time season events        tte #> 1  1      Control  0.02108643   Fall      0 0.08196441 #> 2  1      Control  0.02108643 Spring      0 0.25188227 #> 3  1      Control  0.02108643 Summer      0 0.25188227 #> 4  1      Control  0.02108643 Winter      0 0.14318462 #> 5  2 Experimental  0.03550169   Fall      0 0.08196441 #> 6  2 Experimental  0.03550169 Spring      0 0.25188227 # Summarize events by season library(dplyr) analysis_data %>%   group_by(season, treatment) %>%   summarize(     Subjects = n_distinct(id),     TotalExposure = sum(tte),     TotalEvents = sum(events),     Rate = sum(events) / sum(tte)   ) #> `summarise()` has grouped output by 'season'. You can override using the #> `.groups` argument. #> # A tibble: 8 × 6 #> # Groups:   season [4] #>   season treatment    Subjects TotalExposure TotalEvents  Rate #>   <chr>  <chr>           <int>         <dbl>       <dbl> <dbl> #> 1 Fall   Control            10         0.820           0 0     #> 2 Fall   Experimental       10         0.781           2 2.56  #> 3 Spring Control            10         2.02            1 0.495 #> 4 Spring Experimental       10         2.06            3 1.46  #> 5 Summer Control            10         2.52            0 0     #> 6 Summer Experimental       10         2.52            0 0     #> 7 Winter Control             5         0.395           0 0     #> 8 Winter Experimental        5         0.408           0 0"},{"path":"https://keaven.github.io/gsDesignNB/articles/seasonal-simulation.html","id":"seasonal-and-treatment-effect-estimation","dir":"Articles","previous_headings":"","what":"Seasonal and treatment effect estimation","title":"Seasonal event simulation","text":"can estimate seasonal effects treatment effect using negative binomial generalized linear model. use logarithm exposure time offset.","code":"# Fit negative binomial GLM # We include season and treatment in the model fit <- MASS::glm.nb(   events ~ treatment + season + offset(log(tte)),   data = analysis_data[analysis_data$tte > 0, ] )  # Summary of the model summary(fit) #>  #> Call: #> MASS::glm.nb(formula = events ~ treatment + season + offset(log(tte)),  #>     data = analysis_data[analysis_data$tte > 0, ], init.theta = 0.7046293947,  #>     link = log) #>  #> Coefficients: #>                         Estimate Std. Error z value Pr(>|z|) #> (Intercept)           -9.344e-01  1.230e+00  -0.760    0.447 #> treatmentExperimental  1.712e+00  1.172e+00   1.460    0.144 #> seasonSpring          -1.881e-01  9.655e-01  -0.195    0.845 #> seasonSummer          -3.559e+01  1.501e+07   0.000    1.000 #> seasonWinter          -3.409e+01  1.850e+07   0.000    1.000 #>  #> (Dispersion parameter for Negative Binomial(0.7046) family taken to be 1) #>  #>     Null deviance: 28.268  on 69  degrees of freedom #> Residual deviance: 17.594  on 65  degrees of freedom #> AIC: 45.764 #>  #> Number of Fisher Scoring iterations: 1 #>  #>  #>               Theta:  0.70  #>           Std. Err.:  1.24  #>  #>  2 x log-likelihood:  -33.764  # Extract estimates coef_summary <- summary(fit)$coefficients  # Seasonal effects (relative to reference season, likely Fall based on alphabetical order) # Treatment effect (Experimental vs Control) print(coef_summary) #>                          Estimate   Std. Error       z value  Pr(>|z|) #> (Intercept)            -0.9344423 1.229766e+00 -7.598537e-01 0.4473421 #> treatmentExperimental   1.7117150 1.172198e+00  1.460261e+00 0.1442185 #> seasonSpring           -0.1881428 9.654901e-01 -1.948676e-01 0.8454966 #> seasonSummer          -35.5862751 1.500600e+07 -2.371470e-06 0.9999981 #> seasonWinter          -34.0933221 1.850416e+07 -1.842468e-06 0.9999985  # Estimated Rate Ratio (Experimental / Control) rr <- exp(coef(fit)[\"treatmentExperimental\"]) cat(\"Estimated Rate Ratio (Experimental / Control):\", round(rr, 3), \"\\n\") #> Estimated Rate Ratio (Experimental / Control): 5.538 cat(\"True Design Rate Ratio:\", 0.7, \"\\n\") #> True Design Rate Ratio: 0.7"},{"path":"https://keaven.github.io/gsDesignNB/articles/seasonal-simulation.html","id":"variance-and-information","dir":"Articles","previous_headings":"Seasonal and treatment effect estimation","what":"Variance and information","title":"Seasonal event simulation","text":"variance treatment effect estimate can extracted covariance matrix model. statistical information inverse variance.","code":"# Variance of the treatment effect coefficient var_beta <- vcov(fit)[\"treatmentExperimental\", \"treatmentExperimental\"] cat(\"Variance of Treatment Effect (log-scale):\", var_beta, \"\\n\") #> Variance of Treatment Effect (log-scale): 1.374049  # Statistical Information info <- 1 / var_beta cat(\"Statistical Information:\", info, \"\\n\") #> Statistical Information: 0.7277761"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"simulation-setup","dir":"Articles","previous_headings":"","what":"Simulation setup","title":"Simulation of recurrent events","text":"simulate small trial following parameters: Enrollment: 20 patients total, recruited 5 months constant rate. Treatments: Two groups (Control vs. Experimental) 1:1 allocation ratio. Control: 0.5 events per year. Experimental: 0.3 events per year. Control: 10% annual dropout rate. Experimental: 5% annual dropout rate. Maximum Follow-: patient followed maximum 2 years randomization.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"defining-input-parameters","dir":"Articles","previous_headings":"Simulation setup","what":"Defining input parameters","title":"Simulation of recurrent events","text":"","code":"# Enrollment: rate of 4 patients/month for 5 months -> ~20 patients enroll_rate <- data.frame(   rate = 4,   duration = 5 )  # Failure rates (events per unit time) fail_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.5, 0.3) # events per year (assuming time unit is year, adjust enroll duration if needed) )  # Let's ensure time units are consistent. # If fail_rate is per year, then durations should be in years. # 5 months = 5/12 years. enroll_rate <- data.frame(   rate = 20 / (5 / 12), # 20 patients over 5/12 years   duration = 5 / 12 )  # Dropout rates (per year) dropout_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.1, 0.05),   duration = c(100, 100) # constant rate for long duration )  # Maximum follow-up per patient (years) max_followup <- 2"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"running-the-simulation","dir":"Articles","previous_headings":"","what":"Running the simulation","title":"Simulation of recurrent events","text":"output contains multiple rows per subject: * event = 1: actual recurrent event. * event = 0: censoring time (either due dropout reaching max_followup).","code":"set.seed(123)  sim_data <- nb_sim(   enroll_rate = enroll_rate,   fail_rate = fail_rate,   dropout_rate = dropout_rate,   max_followup = max_followup,   n = 20 )  head(sim_data) #>   id id    treatment enroll_time       tte calendar_time event #> 1  1  1      Control  0.01757203 2.0000000     2.0175720     0 #> 2  2  2 Experimental  0.02958474 0.8651927     0.8947775     1 #> 3  2  2 Experimental  0.02958474 2.0000000     2.0295847     0 #> 4  3  3 Experimental  0.05727338 2.0000000     2.0572734     0 #> 5  4  4      Control  0.05793124 2.0000000     2.0579312     0 #> 6  5  5 Experimental  0.05910231 2.0000000     2.0591023     0"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"analyzing-the-data","dir":"Articles","previous_headings":"","what":"Analyzing the data","title":"Simulation of recurrent events","text":"can aggregate data calculate observed event rates total follow-time group.","code":"sim_dt <- as.data.table(sim_data) sim_dt[, censor_followup := ifelse(event == 0, tte, 0)] summary_stats <- sim_dt[   ,   .(     n_subjects = uniqueN(id),     total_events = sum(event == 1),     total_followup = sum(censor_followup),     observed_rate = sum(event == 1) / sum(censor_followup)   ),   by = treatment ] summary_stats |>   gt() |>   tab_header(title = \"Summary Statistics by Treatment\") |>   cols_label(     treatment = \"Treatment\",     n_subjects = \"N\",     total_events = \"Events\",     total_followup = \"Follow-up\",     observed_rate = \"Rate\"   ) |>   fmt_number(columns = total_followup, decimals = 2) |>   fmt_number(columns = observed_rate, decimals = 3)"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"inspect-first-ten-records","dir":"Articles","previous_headings":"Analyzing the data","what":"Inspect first ten records","title":"Simulation of recurrent events","text":"plotting, can look first ten records simulated dataset.","code":"head(sim_data, 10) #>    id id    treatment enroll_time       tte calendar_time event #> 1   1  1      Control  0.01757203 2.0000000     2.0175720     0 #> 2   2  2 Experimental  0.02958474 0.8651927     0.8947775     1 #> 3   2  2 Experimental  0.02958474 2.0000000     2.0295847     0 #> 4   3  3 Experimental  0.05727338 2.0000000     2.0572734     0 #> 5   4  4      Control  0.05793124 2.0000000     2.0579312     0 #> 6   5  5 Experimental  0.05910231 2.0000000     2.0591023     0 #> 7   6  6 Experimental  0.06569608 2.0000000     2.0656961     0 #> 8   7  7      Control  0.07224248 0.4510840     0.5233265     1 #> 9   7  7      Control  0.07224248 2.0000000     2.0722425     0 #> 10  8  8      Control  0.07526888 2.0000000     2.0752689     0"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"plotting-events","dir":"Articles","previous_headings":"Analyzing the data","what":"Plotting events","title":"Simulation of recurrent events","text":"can visualize events censoring times subject. avoid side-effects data.table, convert dataset back plain data frame. also display event gap event new events can recorded. illustration purposes plot, show 30-day gap visible timeline.","code":"sim_plot <- as.data.frame(sim_data) names(sim_plot) <- make.names(names(sim_plot), unique = TRUE) events_df <- sim_plot[sim_plot$event == 1, ] censor_df <- sim_plot[sim_plot$event == 0, ]  # Define a 30-day gap for visualization (default is usually 5 days) gap_duration <- 30 / 365.25  # Create segments for the gap after each event events_df$gap_start <- events_df$tte events_df$gap_end <- events_df$tte + gap_duration  ggplot(sim_plot, aes(x = tte, y = factor(id), color = treatment)) +   geom_line(aes(group = id), color = \"gray80\") +   # Add gap segments   geom_segment(     data = events_df,     aes(x = gap_start, xend = gap_end, y = factor(id), yend = factor(id)),     color = \"gray50\", linewidth = 2, alpha = 0.7   ) +   geom_point(data = events_df, shape = 19, size = 2) +   geom_point(data = censor_df, shape = 4, size = 3) +   labs(     title = \"Patient Timelines\",     x = \"Time from Randomization (Years)\",     y = \"Patient ID\",     caption = \"Dots = Events, Gray Bars = 30-day Gap, X = Censoring/Dropout\"   ) +   theme_minimal()"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"cutting-data-by-analysis-date","dir":"Articles","previous_headings":"","what":"Cutting data by analysis date","title":"Simulation of recurrent events","text":"can truncate simulated data interim analysis date using cut_data_by_date(). function returns single record per participant truncated follow-time (tte) number observed events. default, 5-day gap (event_gap = 5 / 365.25) applied event, new events counted time risk excluded.","code":"cut_summary <- cut_data_by_date(sim_data, cut_date = 1.5) head(cut_summary) #>   id    treatment enroll_time      tte events #> 1  1      Control  0.01757203 1.482428      0 #> 2  2 Experimental  0.02958474 1.456726      1 #> 3  3 Experimental  0.05727338 1.442727      0 #> 4  4      Control  0.05793124 1.442069      0 #> 5  5 Experimental  0.05910231 1.440898      0 #> 6  6 Experimental  0.06569608 1.434304      0"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"wald-test-mütze-et-al-","dir":"Articles","previous_headings":"","what":"Wald test (Mütze et al.)","title":"Simulation of recurrent events","text":"Using truncated data can run negative binomial Wald test described Mütze et al. (2018).","code":"mutze_res <- mutze_test(cut_summary) mutze_res$group_summary |>   gt() |>   tab_header(title = \"Mütze Test: Group Summary\") |>   fmt_number(columns = c(events, exposure), decimals = 2) mutze_res$rate_ratio #> [1] 0.5273708"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"finding-analysis-date-for-target-events","dir":"Articles","previous_headings":"","what":"Finding analysis date for target events","title":"Simulation of recurrent events","text":"Often want perform interim analysis fixed calendar date, specific number events accumulated. can find date using get_analysis_date() cut data accordingly. function also respects event_gap (defaulting 5 days).","code":"# Target 15 total events target_events <- 15 analysis_date <- get_analysis_date(sim_data, planned_events = target_events) #> Only 11 events in trial  print(paste(\"Calendar date for\", target_events, \"events:\", round(analysis_date, 3))) #> [1] \"Calendar date for 15 events: 2.338\"  # Cut data at this date cut_events <- cut_data_by_date(sim_data, cut_date = analysis_date)  # Verify event count sum(cut_events$events) #> [1] 11"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"generating-and-verifying-negative-binomial-data","dir":"Articles","previous_headings":"","what":"Generating and verifying negative binomial data","title":"Simulation of recurrent events","text":"nb_sim() function can also generate data counts follow negative binomial distribution. achieved providing dispersion parameter fail_rate data frame. dispersion parameter kk relates variance mean Var(Y)=μ+kμ2Var(Y) = \\mu + k\\mu^2.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"simulation-with-dispersion","dir":"Articles","previous_headings":"Generating and verifying negative binomial data","what":"Simulation with dispersion","title":"Simulation of recurrent events","text":"define scenario known dispersion 0.5.","code":"# Define failure rates with dispersion fail_rate_nb <- data.frame(   treatment = \"Control\",   rate = 10, # Mean event rate   dispersion = 0.5 # Variance = mean + 0.5 * mean^2 )  enroll_rate_nb <- data.frame(   rate = 100,   duration = 1 )  set.seed(1) # Simulate 500 subjects to get a stable estimate sim_nb <- nb_sim(   enroll_rate = enroll_rate_nb,   fail_rate = fail_rate_nb,   max_followup = 1,   n = 500,   block = \"Control\" # Assign all to Control for simplicity )"},{"path":"https://keaven.github.io/gsDesignNB/articles/simulation-example.html","id":"verifying-the-dispersion-parameter","dir":"Articles","previous_headings":"Generating and verifying negative binomial data","what":"Verifying the dispersion parameter","title":"Simulation of recurrent events","text":"can verify simulated data reflects input dispersion parameter estimating back data. use Method Moments (MoM) estimator: k̂=Var(Y)−Y‾Y‾2 \\hat{k} = \\frac{Var(Y) - \\bar{Y}}{\\bar{Y}^2}","code":"# Count events per subject counts_nb <- as.data.table(sim_nb)[, .(events = sum(event)), by = id]  m <- mean(counts_nb$events) v <- var(counts_nb$events) k_mom <- (v - m) / (m^2)  # Also estimate using GLM # We use MASS::glm.nb to fit the negative binomial model # We suppress warnings because fitting intercept-only models on simulated data # can occasionally produce convergence warnings despite valid estimates. k_glm <- tryCatch(   {     fit <- suppressWarnings(MASS::glm.nb(events ~ 1, data = counts_nb))     1 / fit$theta   },   error = function(e) NA )  print(paste(\"True Dispersion:\", 0.5)) #> [1] \"True Dispersion: 0.5\" print(paste(\"Estimated Dispersion (MoM):\", signif(k_mom, 4))) #> [1] \"Estimated Dispersion (MoM): 0.5\" print(paste(\"Estimated Dispersion (GLM):\", signif(k_glm, 4))) #> [1] \"Estimated Dispersion (GLM): 0.512\""},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Verification of sample size calculation via simulation","text":"vignette verifies accuracy sample_size_nbinom function comparing theoretical predictions average exposure, statistical information, power results large-scale simulation. specifically test scenario : Piecewise constant accrual rates. Piecewise exponential dropout (constant example). Negative binomial outcomes. Fixed follow-design.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"simulation-design","dir":"Articles","previous_headings":"","what":"Simulation design","title":"Verification of sample size calculation via simulation","text":"simulation parameters chosen yield sample size approximately 200 subjects.","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"parameters","dir":"Articles","previous_headings":"Simulation design","what":"Parameters","title":"Verification of sample size calculation via simulation","text":"Rates: λ1=0.4\\lambda_1 = 0.4 (Control), λ2=0.3\\lambda_2 = 0.3 (Experimental). Dispersion: k=0.5k = 0.5. Power: 90%. Alpha: 0.025 (one-sided). Dropout: 10% per year adjusted monthly rate (δ=0.1/12\\delta = 0.1 / 12). Trial Duration: 24 months. Max Follow-: 12 months. Event Gap: 30 days (approx 0.082 years). Accrual: Piecewise linear ramp-12 months (Rate RR 0-6mo, 2R2R 6-12mo).","code":""},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"theoretical-calculation","dir":"Articles","previous_headings":"Simulation design","what":"Theoretical calculation","title":"Verification of sample size calculation via simulation","text":"First, calculate required sample size expected properties using sample_size_nbinom.","code":"# Parameters lambda1 <- 0.4 lambda2 <- 0.3 dispersion <- 0.5 power <- 0.9 alpha <- 0.025 dropout_rate <- 0.1 / 12 max_followup <- 12 trial_duration <- 24 event_gap <- 20 / 30.42 # 20 days  # Accrual targeting 90% power # We provide relative rates (1:2) and the function scales them to achieve power accrual_rate_rel <- c(1, 2) accrual_duration <- c(6, 6)  design <- sample_size_nbinom(   lambda1 = lambda1, lambda2 = lambda2, dispersion = dispersion,   power = power,   alpha = alpha, sided = 1,   accrual_rate = accrual_rate_rel,   accrual_duration = accrual_duration,   trial_duration = trial_duration,   dropout_rate = dropout_rate,   max_followup = max_followup,   event_gap = event_gap,   method = \"friede\" )  # Extract calculated absolute accrual rates accrual_rate <- design$accrual_rate  print(design) #> Sample size for negative binomial outcome #> ========================================== #>  #> Method:          friede #> Sample size:     n1 = 211, n2 = 211, total = 422 #> Expected events: 1366.9 (n1: 763.1, n2: 603.8) #> Power: 90%, Alpha: 0.025 (1-sided) #> Rates: control = 0.4000, treatment = 0.3000 (RR = 0.7500) #> Dispersion: 0.5000, Avg exposure (calendar): 11.42 #> Avg exposure (at-risk): n1 = 9.04, n2 = 9.54 #> Event gap: 0.66 #> Dropout rate: 0.0083 #> Accrual: 12.0, Trial duration: 24.0 #> Max follow-up: 12.0"},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"simulation-results","dir":"Articles","previous_headings":"","what":"Simulation results","title":"Verification of sample size calculation via simulation","text":"simulated 3,600 trials using parameters defined . number simulations chosen achieve standard error power estimate approximately 0.005 true power 90% (0.9×0.1/3600=0.005\\sqrt{0.9 \\times 0.1 / 3600} = 0.005). simulation script located data-raw/generate_simulation_data.R.","code":"# Load pre-computed simulation results results_file <- system.file(\"extdata\", \"simulation_results.rds\", package = \"gsDesignNB\")  if (results_file == \"\" && file.exists(\"../inst/extdata/simulation_results.rds\")) {   results_file <- \"../inst/extdata/simulation_results.rds\" }  if (results_file != \"\") {   sim_data <- readRDS(results_file)   results <- sim_data$results   design_ref <- sim_data$design } else {   # Fallback if data is not available (e.g. not installed yet)   # This block allows the vignette to build without the data, but warns.   warning(\"Simulation results not found. Skipping verification plots.\")   results <- NULL   design_ref <- design }"},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"average-exposure-verification","dir":"Articles","previous_headings":"Simulation results","what":"1. Average exposure verification","title":"Verification of sample size calculation via simulation","text":"compare theoretical average exposure calculated sample_size_nbinom observed average exposure simulation. Comparison Average Exposure theoretical exposure closely match simulated average exposure.","code":"# Theoretical Exposure theo_exposure <- design_ref$exposure  # Observed Exposure (Average across all trials and arms) # Note: Exposure is the same for both arms in this design (randomized) obs_exposure <- mean(c(results$exposure_control, results$exposure_experimental))  comparison_exp <- data.frame(   Metric = \"Average Exposure\",   Theoretical = theo_exposure,   Simulated = obs_exposure,   Difference = obs_exposure - theo_exposure,   Rel_Diff_Pct = 100 * (obs_exposure - theo_exposure) / theo_exposure )  knitr::kable(comparison_exp, digits = 4, caption = \"Comparison of Average Exposure\")"},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"statistical-information-and-variance","dir":"Articles","previous_headings":"Simulation results","what":"2. Statistical information and variance","title":"Verification of sample size calculation via simulation","text":"theoretical variance log rate ratio estimator (Wald test) given : Vtheo=1/μ1+kadjn1+1/μ2+kadjn2 V_{theo} = \\frac{1/\\mu_1 + k_{adj}}{n_1} + \\frac{1/\\mu_2 + k_{adj}}{n_2} μi=λi,efft‾\\mu_i = \\lambda_{,eff} \\bar{t} expected number events per subject group ii (using effective rates adjusted event gaps), kadj=k⋅Qk_{adj} = k \\cdot Q dispersion parameter inflated variable follow-. dispersion parameter kk directly increases variance estimator. standard Poisson model, k=0k=0, variance depends expected number events. negative binomial dispersion (k>0k > 0), variance inflated, reflecting extra variability (overdispersion) data. compare variance estimates simulation. Comparison Variance Empirical Var: actual variability estimated log rate ratios across 10,000 trials. Avg Estimated Var: average variance estimates (SE2SE^2) produced Wald test trial. Close agreement indicates sample size formula correctly anticipates variability test statistic.","code":"# Theoretical Variance (from design object) theo_var <- design_ref$variance  # Empirical Variance of the Log Hazard Ratio estimates emp_var <- var(results$estimate, na.rm = TRUE)  # Average Squared Standard Error (mean of the estimated variances) avg_se_sq <- mean(results$se^2, na.rm = TRUE)  comparison_var <- data.frame(   Metric = c(\"Variance of Estimator\"),   Theoretical = theo_var,   Empirical_Var = emp_var,   Avg_Estimated_Var = avg_se_sq )  knitr::kable(comparison_var, digits = 5, caption = \"Comparison of Variance\")"},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"power-verification","dir":"Articles","previous_headings":"Simulation results","what":"3. Power verification","title":"Verification of sample size calculation via simulation","text":"Finally, compare theoretical power empirical power (proportion trials rejecting null hypothesis). Comparison Power 95% confidence interval empirical power can calculated check theoretical power falls within simulation error bounds.","code":"# Theoretical Power theo_power <- design_ref$power  # Empirical Power emp_power <- mean(results$p_value < design_ref$inputs$alpha, na.rm = TRUE)  comparison_pwr <- data.frame(   Metric = \"Power\",   Theoretical = theo_power,   Simulated = emp_power,   Difference = emp_power - theo_power )  knitr::kable(comparison_pwr, digits = 4, caption = \"Comparison of Power\") binom.test(sum(results$p_value < design_ref$inputs$alpha, na.rm = TRUE), nrow(results))$conf.int #> [1] 0.8626014 0.8845653 #> attr(,\"conf.level\") #> [1] 0.95"},{"path":"https://keaven.github.io/gsDesignNB/articles/verification-simulation.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Verification of sample size calculation via simulation","text":"simulation results confirm sample_size_nbinom accurately predicts average exposure, variance, power complex design piecewise accrual dropout.","code":""},{"path":"https://keaven.github.io/gsDesignNB/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Keaven Anderson. Author, maintainer.","code":""},{"path":"https://keaven.github.io/gsDesignNB/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson K (2025). gsDesignNB: Sample Size Calculation Simulation Negative Binomial Outcomes. R package version 0.2.0, https://keaven.github.io/gsDesignNB/.","code":"@Manual{,   title = {gsDesignNB: Sample Size Calculation and Simulation for Negative Binomial Outcomes},   author = {Keaven Anderson},   year = {2025},   note = {R package version 0.2.0},   url = {https://keaven.github.io/gsDesignNB/}, }"},{"path":"https://keaven.github.io/gsDesignNB/index.html","id":"gsdesignnb","dir":"","previous_headings":"","what":"Sample Size Calculation and Simulation for Negative Binomial Outcomes","title":"Sample Size Calculation and Simulation for Negative Binomial Outcomes","text":"gsDesignNB provides fixed design group sequential design simulation recurrent event scenarios analyzed Poisson process negative binomial model. group sequential design, package can easily used gsDesign package. Key computation statistical information time analysis.","code":""},{"path":"https://keaven.github.io/gsDesignNB/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Sample Size Calculation and Simulation for Negative Binomial Outcomes","text":"can install gsDesignNB CRAN : install development version GitHub :","code":"install.packages(\"gsDesignNB\") remotes::install_github(\"keaven/gsDesignNB\")"},{"path":"https://keaven.github.io/gsDesignNB/index.html","id":"code-style","dir":"","previous_headings":"","what":"Code style","title":"Sample Size Calculation and Simulation for Negative Binomial Outcomes","text":"package follows tidyverse style guide.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/blinded_ssr.html","id":null,"dir":"Reference","previous_headings":"","what":"Blinded sample size re-estimation for recurrent events — blinded_ssr","title":"Blinded sample size re-estimation for recurrent events — blinded_ssr","text":"Estimates blinded dispersion event rate aggregated interim data calculates required sample size maintain power, assuming planned treatment effect holds. function supports constant rates (Friede & Schmidli 2010) accommodates future extensions time-varying rates (Schneider et al. 2013) using exposure-adjusted rate.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/blinded_ssr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Blinded sample size re-estimation for recurrent events — blinded_ssr","text":"","code":"blinded_ssr(   data,   ratio = 1,   lambda1_planning,   lambda2_planning,   power = 0.8,   alpha = 0.025,   method = \"friede\",   accrual_rate,   accrual_duration,   trial_duration,   dropout_rate = 0,   max_followup = NULL,   event_gap = NULL )"},{"path":"https://keaven.github.io/gsDesignNB/reference/blinded_ssr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Blinded sample size re-estimation for recurrent events — blinded_ssr","text":"data data frame containing blinded interim data. Must include columns events (number events) tte (total exposure/follow-time). typically output cut_data_by_date(). ratio Planned allocation ratio (experimental / control). Default 1. lambda1_planning Planned event rate control group used original calculation. lambda2_planning Planned event rate experimental group used original calculation. power Target power (1 - beta). Default 0.8. alpha One-sided significance level. Default 0.025. method Method sample size recalculation. Currently \"friede\" (Friede & Schmidli 2010) implemented, uses blinded nuisance parameter estimates. accrual_rate Vector accrual rates (patients per unit time). accrual_duration Vector durations accrual rate. Must length accrual_rate. trial_duration Total planned duration trial. dropout_rate Dropout rate (hazard rate). Default 0. max_followup Maximum follow-time patient. Default NULL (infinite). event_gap Gap duration event new events counted. Default NULL (gap).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/blinded_ssr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Blinded sample size re-estimation for recurrent events — blinded_ssr","text":"list containing: n_total_unadjusted Original planned total sample size (based planning parameters). n_total_blinded Re-estimated total sample size using blinded estimates. dispersion_blinded Estimated dispersion parameter (k) blinded data. lambda_blinded Estimated overall event rate blinded data. info_fraction Estimated information fraction interim (blinded information / target information). blinded_info Estimated statistical information blinded interim data. target_info Target statistical information required planned power.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/blinded_ssr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Blinded sample size re-estimation for recurrent events — blinded_ssr","text":"Friede, T., & Schmidli, H. (2010). Blinded sample size reestimation count data: methods applications. Statistics Medicine, 29(10), 1145–1156. doi:10.1002/sim.3891 Schneider, S., Schmidli, H., & Friede, T. (2013). Blinded sample size reestimation recurrent event data time trends. Statistics Medicine, 32(30), 5448–5457. doi:10.1002/sim.5920","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/calculate_blinded_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate blinded statistical information — calculate_blinded_info","title":"Calculate blinded statistical information — calculate_blinded_info","text":"Estimates blinded dispersion event rate aggregated interim data calculates observed statistical information log rate ratio, assuming planned allocation ratio treatment effect.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/calculate_blinded_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate blinded statistical information — calculate_blinded_info","text":"","code":"calculate_blinded_info(   data,   ratio = 1,   lambda1_planning,   lambda2_planning,   event_gap = NULL )"},{"path":"https://keaven.github.io/gsDesignNB/reference/calculate_blinded_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate blinded statistical information — calculate_blinded_info","text":"data data frame containing blinded interim data. Must include columns events (number events) tte (total exposure/follow-time). ratio Planned allocation ratio (experimental / control). Default 1. lambda1_planning Planned event rate control group. lambda2_planning Planned event rate experimental group. event_gap Optional. Gap duration (numeric) adjust planning rates provided. provided, planning rates adjusted lambda / (1 + lambda * gap).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/calculate_blinded_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate blinded statistical information — calculate_blinded_info","text":"list containing: blinded_info Estimated statistical information. dispersion_blinded Estimated dispersion parameter (k). lambda_blinded Estimated overall event rate. lambda1_adjusted Re-estimated control rate. lambda2_adjusted Re-estimated experimental rate.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/compute_info_at_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Statistical Information at Analysis Time — compute_info_at_time","title":"Compute Statistical Information at Analysis Time — compute_info_at_time","text":"Computes statistical information log rate ratio given analysis time, accounting staggered enrollment varying exposure times.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/compute_info_at_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Statistical Information at Analysis Time — compute_info_at_time","text":"","code":"compute_info_at_time(   analysis_time,   accrual_rate,   accrual_duration,   lambda1,   lambda2,   dispersion,   ratio = 1,   dropout_rate = 0,   event_gap = 0 )"},{"path":"https://keaven.github.io/gsDesignNB/reference/compute_info_at_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Statistical Information at Analysis Time — compute_info_at_time","text":"analysis_time calendar time analysis. accrual_rate enrollment rate (subjects per time unit). accrual_duration duration enrollment period. lambda1 Event rate group 1 (control). lambda2 Event rate group 2 (treatment). dispersion negative binomial dispersion parameter. ratio Allocation ratio (n2/n1). Default 1. dropout_rate Dropout rate (hazard rate). Default 0. event_gap Gap duration event new events counted. Default 0.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/compute_info_at_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Statistical Information at Analysis Time — compute_info_at_time","text":"statistical information (inverse variance) analysis time.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_completers.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut data for completers analysis — cut_completers","title":"Cut data for completers analysis — cut_completers","text":"Subsets data subjects randomized specified date, prepares data analysis. wrapper cut_data_by_date() typically used date determined cut_date_for_completers().","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_completers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut data for completers analysis — cut_completers","text":"","code":"cut_completers(data, cut_date, event_gap = 5/365.25)"},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_completers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut data for completers analysis — cut_completers","text":"data Data generated nb_sim(). cut_date Calendar time (relative trial start) cut data. event_gap Gap duration event new events counted. Can numeric value (default 5 / 365.25) function returning numeric value. time risk reduced sum gaps (truncated cut date).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_completers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut data for completers analysis — cut_completers","text":"data frame one row per subject randomized prior cut_date. Contains truncated follow-time (tte) total number observed events (events).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_completers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut data for completers analysis — cut_completers","text":"","code":"enroll_rate <- data.frame(rate = 20 / (5 / 12), duration = 5 / 12) fail_rate <- data.frame(treatment = c(\"Control\", \"Experimental\"), rate = c(0.5, 0.3)) dropout_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.1, 0.05), duration = c(100, 100) ) sim <- nb_sim(enroll_rate, fail_rate, dropout_rate, max_followup = 2, n = 20) # Find date when 5 subjects have completed date_5 <- cut_date_for_completers(sim, 5) # Get analysis dataset for this cut date (includes partial follow-up) cut_completers(sim, date_5) #>    id    treatment enroll_time       tte events #> 1   1      Control  0.00419837 2.0000000      0 #> 2   2 Experimental  0.03844758 2.0000000      0 #> 3   3      Control  0.14626653 1.9863107      1 #> 4   4 Experimental  0.16402103 2.0000000      0 #> 5   5      Control  0.17372445 1.9863107      1 #> 6   6      Control  0.18507951 1.9886449      0 #> 7   7 Experimental  0.18557397 1.9607720      2 #> 8   8 Experimental  0.20588002 1.9678444      0 #> 9   9 Experimental  0.23301460 1.9270206      1 #> 10 10      Control  0.27367404 1.8863612      1 #> 11 11 Experimental  0.30090945 1.8317472      3 #> 12 12      Control  0.34461830 1.7606599      5 #> 13 13      Control  0.37061731 1.8031071      0 #> 14 14      Control  0.37480352 1.7715424      2 #> 15 15 Experimental  0.41551077 0.5191834      0 #> 16 16 Experimental  0.41625369 1.7437815      1 #> 17 17      Control  0.42441302 1.7356222      1 #> 18 18 Experimental  0.43226952 1.7277657      1 #> 19 19      Control  0.50772960 1.6659948      0 #> 20 20 Experimental  0.51633101 1.6437042      1"},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_data_by_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut simulated trial data at a calendar date — cut_data_by_date","title":"Cut simulated trial data at a calendar date — cut_data_by_date","text":"Censors follow-specified calendar time aggregates events per subject. Returns one row per subject randomized cut date, total number observed events truncated follow-time (adjusted event gaps).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_data_by_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut simulated trial data at a calendar date — cut_data_by_date","text":"","code":"cut_data_by_date(data, cut_date, event_gap = 5/365.25, ...)"},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_data_by_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut simulated trial data at a calendar date — cut_data_by_date","text":"data Data generated nb_sim(). cut_date Calendar time (relative trial start) censor follow-. event_gap Gap duration event new events counted. Can numeric value (default 5 / 365.25) function returning numeric value. time risk reduced sum gaps (truncated cut date). ... Additional arguments passed methods.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_data_by_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut simulated trial data at a calendar date — cut_data_by_date","text":"data frame one row per subject randomized prior cut_date containing truncated follow-time (tte) total number observed events (events).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_data_by_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut simulated trial data at a calendar date — cut_data_by_date","text":"","code":"enroll_rate <- data.frame(rate = 20 / (5 / 12), duration = 5 / 12) fail_rate <- data.frame(treatment = c(\"Control\", \"Experimental\"), rate = c(0.5, 0.3)) dropout_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.1, 0.05), duration = c(100, 100) ) sim <- nb_sim(enroll_rate, fail_rate, dropout_rate, max_followup = 2, n = 20) cut_data_by_date(sim, cut_date = 1) #>    id    treatment enroll_time       tte events #> 1   1 Experimental  0.04814947 0.9518505      0 #> 2   2      Control  0.04968518 0.8567431      0 #> 3   3 Experimental  0.08092913 0.9179037      1 #> 4   4      Control  0.10135757 0.3342787      1 #> 5   5 Experimental  0.12509265 0.8749074      0 #> 6   6 Experimental  0.12654618 0.8734538      0 #> 7   7      Control  0.13208227 0.8542285      1 #> 8   8      Control  0.13254571 0.8674543      0 #> 9   9 Experimental  0.13558272 0.8644173      0 #> 10 10 Experimental  0.19885878 0.8011412      0 #> 11 11      Control  0.20239567 0.7839151      1 #> 12 12      Control  0.22002267 0.7799773      0 #> 13 13 Experimental  0.22429347 0.7757065      0 #> 14 14      Control  0.22803670 0.7719633      0 #> 15 15 Experimental  0.23883497 0.7611650      0 #> 16 16      Control  0.25283811 0.7471619      0 #> 17 17 Experimental  0.26378892 0.7362111      0 #> 18 18 Experimental  0.29216864 0.6005228      1 #> 19 19      Control  0.32322892 0.6767711      0 #> 20 20      Control  0.37266560 0.6273344      0"},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_date_for_completers.html","id":null,"dir":"Reference","previous_headings":"","what":"Find calendar date for target completer count — cut_date_for_completers","title":"Find calendar date for target completer count — cut_date_for_completers","text":"Finds calendar time (since start randomization) specified number subjects completed follow-.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_date_for_completers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find calendar date for target completer count — cut_date_for_completers","text":"","code":"cut_date_for_completers(data, target_completers)"},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_date_for_completers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find calendar date for target completer count — cut_date_for_completers","text":"data data frame simulated data, typically nb_sim(). target_completers Integer. target number completers.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/cut_date_for_completers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find calendar date for target completer count — cut_date_for_completers","text":"Numeric. calendar date target_completers achieved. dataset contains fewer target_completers completers, returns maximum calendar time dataset prints message.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/get_analysis_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Find calendar date for target event count — get_analysis_date","title":"Find calendar date for target event count — get_analysis_date","text":"Finds calendar time (since start randomization) specified total number events reached simulated dataset.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/get_analysis_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find calendar date for target event count — get_analysis_date","text":"","code":"get_analysis_date(data, planned_events, event_gap = 5/365.25)"},{"path":"https://keaven.github.io/gsDesignNB/reference/get_analysis_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find calendar date for target event count — get_analysis_date","text":"data data frame simulated data, typically nb_sim(). planned_events Integer. target number events. event_gap Gap duration event new events counted. Can numeric value (default 5 / 365.25) function returning numeric value.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/get_analysis_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find calendar date for target event count — get_analysis_date","text":"Numeric. calendar date planned_events achieved. dataset contains fewer planned_events, returns maximum calendar time dataset prints message.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/get_analysis_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find calendar date for target event count — get_analysis_date","text":"","code":"enroll_rate <- data.frame(rate = 20 / (5 / 12), duration = 5 / 12) fail_rate <- data.frame(treatment = c(\"Control\", \"Experimental\"), rate = c(0.5, 0.3)) dropout_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.1, 0.05), duration = c(100, 100) ) sim <- nb_sim(enroll_rate, fail_rate, dropout_rate, max_followup = 2, n = 40) get_analysis_date(sim, planned_events = 15) #> [1] 1.447487"},{"path":"https://keaven.github.io/gsDesignNB/reference/gsNBCalendar.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential design for negative binomial outcomes — gsNBCalendar","title":"Group sequential design for negative binomial outcomes — gsNBCalendar","text":"Creates group sequential design negative binomial outcomes based sample size calculations sample_size_nbinom().","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/gsNBCalendar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential design for negative binomial outcomes — gsNBCalendar","text":"","code":"gsNBCalendar(   x,   k = 3,   test.type = 4,   alpha = 0.025,   beta = 0.1,   astar = 0,   delta = 0,   timing = 1,   sfu = gsDesign::sfHSD,   sfupar = -4,   sfl = gsDesign::sfHSD,   sflpar = -2,   tol = 1e-06,   r = 18,   usTime = NULL,   lsTime = NULL,   analysis_times = NULL )"},{"path":"https://keaven.github.io/gsDesignNB/reference/gsNBCalendar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential design for negative binomial outcomes — gsNBCalendar","text":"x object class sample_size_nbinom_result sample_size_nbinom(). k Number analyses (interim + final). Default 3. test.type Test type gsDesign::gsDesign(): 1 One-sided 2 Two-sided symmetric 3 Two-sided, asymmetric, binding futility bound, beta-spending 4 Two-sided, asymmetric, non-binding futility bound, beta-spending 5 Two-sided, asymmetric, binding futility bound, lower spending 6 Two-sided, asymmetric, non-binding futility bound, lower spending Default 4. alpha Type error (one-sided). Default 0.025. beta Type II error (1 - power). Default 0.1. astar Allocated Type error lower bound test.type = 5 6. Default 0. delta Standardized effect size. Default 0 (computed design). timing Timing interim analyses. May vector length k-1 values 0 1 representing information fractions. Default 1 (equally spaced). sfu Spending function upper bound. Default gsDesign::sfHSD. sfupar Parameter upper spending function. Default -4. sfl Spending function lower bound. Default gsDesign::sfHSD. sflpar Parameter lower spending function. Default -2. tol Tolerance convergence. Default 1e-06. r Integer controlling grid size numerical integration. Default 18. usTime Spending time upper bound (optional). lsTime Spending time lower bound (optional). analysis_times Optional vector calendar times analysis. provided, must length k. times stored T element displayed gsDesign::gsBoundSummary().","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/gsNBCalendar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group sequential design for negative binomial outcomes — gsNBCalendar","text":"object class gsNB inherits gsDesign sample_size_nbinom_result. Contains elements gsDesign::gsDesign() plus: nb_design original sample_size_nbinom_result object n1 Sample size per analysis group 1 n2 Sample size per analysis group 2 T Calendar time analysis (analysis_times provided)","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/gsNBCalendar.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Group sequential design for negative binomial outcomes — gsNBCalendar","text":"Jennison, C. Turnbull, B.W. (2000), Group Sequential Methods Applications Clinical Trials. Boca Raton: Chapman Hall.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/gsNBCalendar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential design for negative binomial outcomes — gsNBCalendar","text":"","code":"# First create a sample size calculation nb_ss <- sample_size_nbinom(   lambda1 = 0.5, lambda2 = 0.3, dispersion = 0.1, power = 0.9,   accrual_rate = 10, accrual_duration = 20, trial_duration = 24 )  # Then create a group sequential design with analysis times gs_design <- gsNBCalendar(nb_ss,   k = 3, test.type = 4,   analysis_times = c(10, 18, 24) )"},{"path":"https://keaven.github.io/gsDesignNB/reference/mutze_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Wald test for treatment effect using negative binomial model (Mütze et al.) — mutze_test","title":"Wald test for treatment effect using negative binomial model (Mütze et al.) — mutze_test","text":"Fits negative binomial (Poisson) log-rate model aggregated subject-level data produced cut_data_by_date(). method matches Wald test described Mütze et al. (2018) comparing treatment arms recurrent event outcomes.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/mutze_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wald test for treatment effect using negative binomial model (Mütze et al.) — mutze_test","text":"","code":"mutze_test(data, method = c(\"nb\", \"poisson\"), conf_level = 0.95)"},{"path":"https://keaven.github.io/gsDesignNB/reference/mutze_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wald test for treatment effect using negative binomial model (Mütze et al.) — mutze_test","text":"data data frame least columns treatment, events, tte (follow-time). Typically output cut_data_by_date(). method Type model fit: \"nb\" (default) uses negative binomial GLM via MASS::glm.nb(), \"poisson\" fits Poisson GLM. conf_level Confidence level rate ratio interval. Default 0.95.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/mutze_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wald test for treatment effect using negative binomial model (Mütze et al.) — mutze_test","text":"list containing fitted model summary elements: estimate: log rate ratio (experimental vs control). se: standard error log rate ratio. z: Wald statistic. p_value: two-sided p-value. rate_ratio: estimated rate ratio confidence interval. dispersion: estimated dispersion (theta) method = \"nb\". group_summary: observed subjects/events/exposure per treatment.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/mutze_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wald test for treatment effect using negative binomial model (Mütze et al.) — mutze_test","text":"","code":"enroll_rate <- data.frame(rate = 20 / (5 / 12), duration = 5 / 12) fail_rate <- data.frame(treatment = c(\"Control\", \"Experimental\"), rate = c(0.5, 0.3)) dropout_rate <- data.frame(   treatment = c(\"Control\", \"Experimental\"),   rate = c(0.1, 0.05), duration = c(100, 100) ) sim <- nb_sim(enroll_rate, fail_rate, dropout_rate, max_followup = 2, n = 40) cut <- cut_data_by_date(sim, cut_date = 1.5) mutze_test(cut) #> $method #> [1] \"Negative binomial Wald\" #>  #> $estimate #> [1] 0.1596326 #>  #> $se #> [1] 0.4810408 #>  #> $z #> [1] 0.3318484 #>  #> $p_value #> [1] 0.7400037 #>  #> $rate_ratio #> [1] 1.17308 #>  #> $conf_int #> [1] 0.456946 3.011551 #>  #> $conf_level #> [1] 0.95 #>  #> $dispersion #> [1] 15.81963 #>  #> $model #>  #> Call:  MASS::glm.nb(formula = events ~ treatment + offset(log(tte)),  #>     data = df, init.theta = 15.81962521, link = log) #>  #> Coefficients: #>           (Intercept)  treatmentExperimental   #>               -0.9398                 0.1596   #>  #> Degrees of Freedom: 39 Total (i.e. Null);  38 Residual #> Null Deviance:\t    39.15  #> Residual Deviance: 39.04 \tAIC: 76.6 #>  #> $group_summary #>      treatment subjects events exposure #> 1      Control       20      8 20.50201 #> 2 Experimental       20     10 21.87676 #>"},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate recurrent events with fixed follow-up — nb_sim","title":"Simulate recurrent events with fixed follow-up — nb_sim","text":"Simulates recurrent events clinical trial piecewise constant enrollment, exponential failure rates (Poisson process), piecewise exponential dropout.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate recurrent events with fixed follow-up — nb_sim","text":"","code":"nb_sim(   enroll_rate,   fail_rate,   dropout_rate = NULL,   max_followup = NULL,   n = NULL,   block = c(rep(\"Control\", 2), rep(\"Experimental\", 2)),   event_gap = 0 )"},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate recurrent events with fixed follow-up — nb_sim","text":"enroll_rate data frame columns rate duration defining piecewise constant enrollment rates. fail_rate data frame columns treatment rate defining exponential failure rate treatment group. Optionally, dispersion column can provided generate data negative binomial distribution. dispersion parameter k \\(Var(Y) = \\mu + k \\mu^2\\). dropout_rate data frame columns treatment, rate, duration defining piecewise constant dropout rates. max_followup Numeric. Maximum duration follow-individual (relative randomization time). n Total sample size. NULL, estimated enroll_rate. provided, enrollment stops n subjects recruited. block Block vector treatment allocation. Default c(rep(\"Control\", 2), rep(\"Experimental\", 2)). NULL, simple randomization used (treatments assigned equal probability). provided, specifies block structure, example, c(rep(\"\", 2), rep(\"B\", 2)) assigns 2 group 2 group B block. event_gap Numeric. Gap duration event new events counted. Default 0.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate recurrent events with fixed follow-up — nb_sim","text":"data frame (tibble) columns: id Subject identifier treatment Treatment group enroll_time Time enrollment relative trial start tte Time event censoring relative randomization calendar_time Calendar time event censoring (enroll_time + tte) event Binary indicator: 1 event, 0 censoring Multiple rows per subject returned (one event, plus one final censoring time).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate recurrent events with fixed follow-up — nb_sim","text":"simulation generates data consistent negative binomial models described Friede Schmidli (2010) Mutze et al. (2018). Specifically, simulates Gamma-distributed frailty variable individual (dispersion > 0), acts multiplier individual's event rate. Events generated according Poisson process subject-specific rate.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate recurrent events with fixed follow-up — nb_sim","text":"Friede, T., & Schmidli, H. (2010). Blinded sample size reestimation count data: methods applications. Statistics Medicine, 29(10), 1145–1156. doi:10.1002/sim.3891 Mütze, T., Glimm, E., Schmidli, H., & Friede, T. (2018). Group sequential designs negative binomial outcomes. Statistical Methods Medical Research, 27(10), 2978–2993. doi:10.1177/0962280218773115","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim_seasonal.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate recurrent events with seasonal rates — nb_sim_seasonal","title":"Simulate recurrent events with seasonal rates — nb_sim_seasonal","text":"Simulates recurrent events event rates depend season.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim_seasonal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate recurrent events with seasonal rates — nb_sim_seasonal","text":"","code":"nb_sim_seasonal(   enroll_rate,   fail_rate,   dropout_rate = NULL,   max_followup = NULL,   randomization_start_date = NULL,   n = NULL,   block = c(rep(\"Control\", 2), rep(\"Experimental\", 2)) )"},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim_seasonal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate recurrent events with seasonal rates — nb_sim_seasonal","text":"enroll_rate data frame columns rate duration. fail_rate data frame columns treatment, season, rate, optionally dispersion. Seasons \"Spring\", \"Summer\", \"Fall\", \"Winter\". dropout_rate data frame columns treatment, rate, duration. max_followup Numeric. Max follow-duration (years). randomization_start_date Date. Start randomization. n Integer. Total sample size. block Character vector block randomization.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/nb_sim_seasonal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate recurrent events with seasonal rates — nb_sim_seasonal","text":"data frame class nb_sim_seasonal columns: id, treatment, season, enroll_time, start, end, event, calendar_start, calendar_end. Rows represent intervals risk events. event=1 indicates event end. event=0 indicates censoring end seasonal interval end.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.gsNBsummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for gsNBsummary Objects — print.gsNBsummary","title":"Print Method for gsNBsummary Objects — print.gsNBsummary","text":"Print Method gsNBsummary Objects","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.gsNBsummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for gsNBsummary Objects — print.gsNBsummary","text":"","code":"# S3 method for class 'gsNBsummary' print(x, ...)"},{"path":"https://keaven.github.io/gsDesignNB/reference/print.gsNBsummary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for gsNBsummary Objects — print.gsNBsummary","text":"x object class gsNBsummary. ... Additional arguments (currently ignored).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.gsNBsummary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for gsNBsummary Objects — print.gsNBsummary","text":"Invisibly returns input object.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.sample_size_nbinom_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for sample_size_nbinom_result Objects — print.sample_size_nbinom_result","title":"Print Method for sample_size_nbinom_result Objects — print.sample_size_nbinom_result","text":"Prints concise summary sample size calculation results.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.sample_size_nbinom_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for sample_size_nbinom_result Objects — print.sample_size_nbinom_result","text":"","code":"# S3 method for class 'sample_size_nbinom_result' print(x, ...)"},{"path":"https://keaven.github.io/gsDesignNB/reference/print.sample_size_nbinom_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for sample_size_nbinom_result Objects — print.sample_size_nbinom_result","text":"x object class sample_size_nbinom_result. ... Additional arguments (currently ignored).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.sample_size_nbinom_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for sample_size_nbinom_result Objects — print.sample_size_nbinom_result","text":"Invisibly returns input object.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.sample_size_nbinom_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for sample_size_nbinom_summary Objects — print.sample_size_nbinom_summary","title":"Print Method for sample_size_nbinom_summary Objects — print.sample_size_nbinom_summary","text":"Print Method sample_size_nbinom_summary Objects","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.sample_size_nbinom_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for sample_size_nbinom_summary Objects — print.sample_size_nbinom_summary","text":"","code":"# S3 method for class 'sample_size_nbinom_summary' print(x, ...)"},{"path":"https://keaven.github.io/gsDesignNB/reference/print.sample_size_nbinom_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for sample_size_nbinom_summary Objects — print.sample_size_nbinom_summary","text":"x object class sample_size_nbinom_summary. ... Additional arguments (currently ignored).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/print.sample_size_nbinom_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for sample_size_nbinom_summary Objects — print.sample_size_nbinom_summary","text":"Invisibly returns input object.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. gsDesign gsBoundSummary, gsDesign, sfBetaDist, sfCauchy, sfExponential, sfExtremeValue, sfExtremeValue2, sfGapped, sfHSD, sfLDOF, sfLDPocock, sfLinear, sfLogistic, sfNormal, sfPoints, sfPower, sfStep, sfTDist, sfTrimmed, sfTruncated, sfXG1, sfXG2, sfXG3","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/sample_size_nbinom.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample size calculation for negative binomial distribution — sample_size_nbinom","title":"Sample size calculation for negative binomial distribution — sample_size_nbinom","text":"Computes sample size comparing two treatment groups assuming negative binomial distribution outcome.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/sample_size_nbinom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample size calculation for negative binomial distribution — sample_size_nbinom","text":"","code":"sample_size_nbinom(   lambda1,   lambda2,   dispersion,   power = NULL,   alpha = 0.025,   sided = 1,   ratio = 1,   accrual_rate,   accrual_duration,   trial_duration,   dropout_rate = 0,   max_followup = NULL,   event_gap = NULL,   method = \"zhu\" )"},{"path":"https://keaven.github.io/gsDesignNB/reference/sample_size_nbinom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample size calculation for negative binomial distribution — sample_size_nbinom","text":"lambda1 Rate group 1 (control). lambda2 Rate group 2 (treatment). dispersion Dispersion parameter k \\(Var(Y) = \\mu + k \\mu^2\\). Note equivalent 1/size R's stats::rnbinom() parameterization. power Power test (1 - beta). Default 0.9. alpha Significance level. Default 0.025. sided One-sided two-sided test. 1 one-sided, 2 two-sided. Default 1. ratio Allocation ratio n2/n1. Default 1. accrual_rate Vector accrual rates (patients per unit time). accrual_duration Vector durations accrual rate. Must length accrual_rate. trial_duration Total planned duration trial. dropout_rate Dropout rate (hazard rate). Default 0. max_followup Maximum follow-time patient. Default NULL (infinite). event_gap Gap duration event new events counted. Default NULL (gap). provided, effective event rate reduced. method Method sample size calculation. \"zhu\" Zhu Lakkis (2014), \"friede\" Friede Schmidli (2010) / Mütze et al. (2018).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/sample_size_nbinom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample size calculation for negative binomial distribution — sample_size_nbinom","text":"object class sample_size_nbinom_result, list containing: inputs Named list original function arguments. n1 Sample size group 1 n2 Sample size group 2 n_total Total sample size exposure Average exposure time used calculation (calendar time) exposure_at_risk_n1 Average -risk exposure time group 1 (accounts event gap) exposure_at_risk_n2 Average -risk exposure time group 2 (accounts event gap)","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/sample_size_nbinom.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample size calculation for negative binomial distribution — sample_size_nbinom","text":"Zhu, H., & Lakkis, H. (2014). Sample size calculation comparing two negative binomial rates clinical trials. Statistics Biopharmaceutical Research, 6(1), 107–115. doi:10.1080/19466315.2013.870533 Friede, T., & Schmidli, H. (2010). Sample size estimation clinical trials negative binomial rates. Methods Information Medicine, 49(6), 623–631. doi:10.3414/ME09-01-0058 Mütze, T., Glimm, E., Schmidli, H., & Friede, T. (2018). Group sequential designs negative binomial outcomes. Statistical Methods Medical Research, 27(10), 2978–2993. doi:10.1177/0962280218773115","code":""},{"path":[]},{"path":"https://keaven.github.io/gsDesignNB/reference/sample_size_nbinom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample size calculation for negative binomial distribution — sample_size_nbinom","text":"","code":"# Calculate sample size for lambda1 = 0.5, lambda2 = 0.3, dispersion = 0.1 # with fixed recruitment of 10/month for 20 months, 24 month trial duration x <- sample_size_nbinom(   lambda1 = 0.5, lambda2 = 0.3, dispersion = 0.1, power = 0.8,   accrual_rate = 10, accrual_duration = 20, trial_duration = 24 ) class(x) #> [1] \"sample_size_nbinom_result\" \"list\"                      summary(x) #> Fixed sample size design for negative binomial outcome (zhu method), total #> sample size 38 (n1=19, n2=19), 80 percent power, 2.5 percent (1-sided) Type I #> error. Control rate 0.5000, treatment rate 0.3000, risk ratio 0.6000, #> dispersion 0.1000. Accrual duration 20.0, trial duration 24.0, average exposure #> 14.00. Expected events 212.8. Randomization ratio 1:1. #>   # With piecewise accrual # 5 patients/month for 3 months, then 10 patients/month for 3 months # Trial ends at month 12. x2 <- sample_size_nbinom(   lambda1 = 0.5, lambda2 = 0.3, dispersion = 0.1, power = 0.8,   accrual_rate = c(5, 10), accrual_duration = c(3, 3),   trial_duration = 12 ) summary(x2) #> Fixed sample size design for negative binomial outcome (zhu method), total #> sample size 52 (n1=26, n2=26), 80 percent power, 2.5 percent (1-sided) Type I #> error. Control rate 0.5000, treatment rate 0.3000, risk ratio 0.6000, #> dispersion 0.1000. Accrual duration 6.0, trial duration 12.0, average exposure #> 8.50. Expected events 176.8. Randomization ratio 1:1. #>"},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.gsNB.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for gsNB Objects — summary.gsNB","title":"Summary for gsNB Objects — summary.gsNB","text":"Provides textual summary group sequential design negative binomial outcomes, similar summary provided gsDesign::gsDesign(). tabular output, use gsDesign::gsBoundSummary() directly gsNB object.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.gsNB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for gsNB Objects — summary.gsNB","text":"","code":"# S3 method for class 'gsNB' summary(object, ...)"},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.gsNB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for gsNB Objects — summary.gsNB","text":"object object class gsNB. ... Additional arguments (currently ignored).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.gsNB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for gsNB Objects — summary.gsNB","text":"character string summarizing design (invisibly). summary also printed console.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.gsNB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for gsNB Objects — summary.gsNB","text":"","code":"nb_ss <- sample_size_nbinom(   lambda1 = 0.5, lambda2 = 0.3, dispersion = 0.1, power = 0.9,   accrual_rate = 10, accrual_duration = 20, trial_duration = 24 ) gs_design <- gsNBCalendar(nb_ss, k = 3) summary(gs_design) #> Asymmetric two-sided with non-binding futility bound group sequential design #> for negative binomial outcomes, 3 analyses, total sample size 53.5, 90 percent #> power, 2.5 percent (1-sided) Type I error. Control rate 0.5000, treatment rate #> 0.3000, risk ratio 0.6000, dispersion 0.1000. Accrual duration 20.0, trial #> duration 24.0, average exposure 14.00. Randomization ratio 1:1. #>   # For tabular bounds summary, use gsBoundSummary directly: # gsDesign::gsBoundSummary(gs_design)"},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.sample_size_nbinom_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for sample_size_nbinom_result Objects — summary.sample_size_nbinom_result","title":"Summary for sample_size_nbinom_result Objects — summary.sample_size_nbinom_result","text":"Provides textual summary sample size calculation negative binomial outcomes, similar summary gsNB objects.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.sample_size_nbinom_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for sample_size_nbinom_result Objects — summary.sample_size_nbinom_result","text":"","code":"# S3 method for class 'sample_size_nbinom_result' summary(object, ...)"},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.sample_size_nbinom_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for sample_size_nbinom_result Objects — summary.sample_size_nbinom_result","text":"object object class sample_size_nbinom_result. ... Additional arguments (currently ignored).","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.sample_size_nbinom_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for sample_size_nbinom_result Objects — summary.sample_size_nbinom_result","text":"character string summarizing design (invisibly). summary also printed console.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/summary.sample_size_nbinom_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for sample_size_nbinom_result Objects — summary.sample_size_nbinom_result","text":"","code":"x <- sample_size_nbinom(   lambda1 = 0.5, lambda2 = 0.3, dispersion = 0.1, power = 0.8,   accrual_rate = 10, accrual_duration = 20, trial_duration = 24 ) class(x) #> [1] \"sample_size_nbinom_result\" \"list\"                      summary(x) #> Fixed sample size design for negative binomial outcome (zhu method), total #> sample size 38 (n1=19, n2=19), 80 percent power, 2.5 percent (1-sided) Type I #> error. Control rate 0.5000, treatment rate 0.3000, risk ratio 0.6000, #> dispersion 0.1000. Accrual duration 20.0, trial duration 24.0, average exposure #> 14.00. Expected events 212.8. Randomization ratio 1:1. #>"},{"path":"https://keaven.github.io/gsDesignNB/reference/toInteger.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Group Sequential Design to Integer Sample Sizes — toInteger","title":"Convert Group Sequential Design to Integer Sample Sizes — toInteger","text":"Generic function round sample sizes group sequential design integers. extends gsDesign::toInteger() function gsDesign package work gsNB objects.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/toInteger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Group Sequential Design to Integer Sample Sizes — toInteger","text":"","code":"toInteger(x, ...)  # S3 method for class 'gsDesign' toInteger(x, ratio = x$ratio, roundUpFinal = TRUE, ...)  # S3 method for class 'gsNB' toInteger(x, ratio = x$nb_design$inputs$ratio, roundUpFinal = TRUE, ...)"},{"path":"https://keaven.github.io/gsDesignNB/reference/toInteger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Group Sequential Design to Integer Sample Sizes — toInteger","text":"x object class gsNB gsDesign. ... Additional arguments passed methods. ratio Randomization ratio (n2/n1). integer provided, rounding done multiple ratio + 1. Default uses ratio original design. roundUpFinal TRUE (default), final sample size rounded ensure target met. FALSE, rounding nearest integer.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/toInteger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Group Sequential Design to Integer Sample Sizes — toInteger","text":"object class input integer sample sizes.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/toInteger.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Group Sequential Design to Integer Sample Sizes — toInteger","text":"function rounds sample sizes analysis integers maintaining randomization ratio ensuring monotonically increasing sample sizes across analyses. final analysis sample size rounded integer; interim sample sizes remain expected (non-integer) values based information fraction. analysis_times provided gsNBCalendar(), statistical information (n.) recomputed analysis time based new sample size expected exposures.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/toInteger.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Convert Group Sequential Design to Integer Sample Sizes — toInteger","text":"toInteger(gsDesign): Method gsDesign objects (calls gsDesign::toInteger()). toInteger(gsNB): Method gsNB objects. Rounds sample sizes group sequential negative binomial design integers, respecting randomization ratio.","code":""},{"path":"https://keaven.github.io/gsDesignNB/reference/toInteger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Group Sequential Design to Integer Sample Sizes — toInteger","text":"","code":"nb_ss <- sample_size_nbinom(   lambda1 = 0.5, lambda2 = 0.3, dispersion = 0.1, power = 0.9,   accrual_rate = 10, accrual_duration = 20, trial_duration = 24 ) gs_design <- gsNBCalendar(nb_ss, k = 3) gs_integer <- toInteger(gs_design)"}]
