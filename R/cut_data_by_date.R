#' Cut nb_sim data by calendar date
#'
#' @param data Data generated by [nb_sim()].
#' @param ... Additional arguments passed to methods.
#' @param cut_date Calendar time (relative to trial start) at which to censor follow-up.
#' @param event_gap Gap duration after each event during which no new events are counted.
#'   Can be a numeric value (default `5 / 365.25`) or a function returning a numeric value.
#'   The time at risk is reduced by the sum of these gaps (truncated by the cut date).
#'
#' @return A data frame with one row per subject randomized prior to `cut_date` containing
#'   the truncated follow-up time (`tte`) and total number of observed events (`events`).
#'
#' @examples
#' enroll_rate <- data.frame(rate = 20 / (5 / 12), duration = 5 / 12)
#' fail_rate <- data.frame(treatment = c("Control", "Experimental"), rate = c(0.5, 0.3))
#' dropout_rate <- data.frame(
#'   treatment = c("Control", "Experimental"),
#'   rate = c(0.1, 0.05), duration = c(100, 100)
#' )
#' sim <- nb_sim(enroll_rate, fail_rate, dropout_rate, max_followup = 2, n = 20)
#' cut_data_by_date(sim, cut_date = 1)
#' @export
cut_data_by_date <- function(data, cut_date, ...) {
  UseMethod("cut_data_by_date")
}

#' @export
cut_data_by_date.default <- function(data, cut_date, ...) {
  stop("No cut_data_by_date() method for objects of class ", class(data)[1], call. = FALSE)
}

#' @export
cut_data_by_date.nb_sim_data <- function(data, cut_date, event_gap = 5 / 365.25, ...) {
  if (is.null(cut_date) || length(cut_date) != 1L || !is.finite(cut_date)) {
    stop("cut_date must be a single finite numeric value", call. = FALSE)
  }

  dt <- data.table::as.data.table(data)
  dt[, calendar_time := enroll_time + tte]
  dt <- dt[enroll_time < cut_date]
  if (nrow(dt) == 0) {
    return(data.frame(
      id = integer(0), treatment = character(0), enroll_time = numeric(0),
      tte = numeric(0), events = integer(0)
    ))
  }

  calc_gap_stats <- function(events_t, limit, gap_rule) {
    events_t <- sort(events_t)
    events_t <- events_t[events_t <= limit] # Should be redundant but safe
    
    count <- 0L
    gap_total <- 0
    last_gap_end <- -Inf
    
    for (t in events_t) {
      if (t < last_gap_end) next
      
      count <- count + 1L
      g <- if (is.function(gap_rule)) gap_rule() else gap_rule
      
      gap_end <- t + g
      # Only subtract gap time within the observation window
      effective_end <- min(gap_end, limit)
      gap_dur <- max(0, effective_end - t)
      
      gap_total <- gap_total + gap_dur
      last_gap_end <- gap_end
    }
    list(events = count, tte = limit - gap_total)
  }

  agg <- dt[,
    {
      followup_limit <- cut_date - first(enroll_time)
      followup_limit <- max(followup_limit, 0)
      tte_in_window <- tte[calendar_time <= cut_date]
      max_tte_in_window <- if (length(tte_in_window)) max(tte_in_window) else 0
      overall_max_tte <- max(tte)
      max_tte <- min(overall_max_tte, followup_limit)
      max_tte <- max(max_tte, max_tte_in_window)
      
      events_vec <- tte[event == 1 & calendar_time <= cut_date]
      res <- calc_gap_stats(events_vec, max_tte, event_gap)
      
      list(
        treatment = first(treatment),
        enroll_time = first(enroll_time),
        tte = res$tte,
        events = as.integer(res$events)
      )
    },
    by = id
  ]

  data.table::setorder(agg, id)
  out <- as.data.frame(agg)
  out
}
